<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeRTOS任务间通信概述</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #bbdefb 50%, #f8bbd0 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
            border: 2px solid #4fc3f7;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px dashed #4fc3f7;
        }

        h1 {
            color: #0277bd;
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #0288d1;
            margin: 25px 0 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #b3e5fc;
        }

        h3 {
            color: #039be5;
            margin: 20px 0 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .intro {
            background-color: #e1f5fe;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #4fc3f7;
        }

        .card {
            background-color: #f9f9f9;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
            border: 1px solid #e0e0e0;
        }

        .card h3 {
            color: #01579b;
            display: flex;
            align-items: center;
        }

        .card h3 svg {
            margin-right: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background-color: #4fc3f7;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f5f5f5;
        }

        tr:hover {
            background-color: #e1f5fe;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        li {
            margin-bottom: 8px;
        }

        pre {
            background-color: #f5f5f5;
            border-left: 4px solid #4fc3f7;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        code {
            background-color: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .comparison {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
        }

        .comparison-item {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        .comparison-item h3 {
            color: #0277bd;
            text-align: center;
            margin-bottom: 15px;
        }

        .architecture {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin: 30px 0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
        }

        .architecture h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #0277bd;
            font-weight: bold;
            border-top: 2px dashed #4fc3f7;
        }

        .icon {
            width: 24px;
            height: 24px;
            margin-right: 10px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FreeRTOS任务间通信概述</h1>
            <p>《FreeRTOS任务管理50问》第40问：任务间通信的各种方式</p>
        </header>

        <section class="intro">
            <h2>引言</h2>
            <p>在嵌入式实时操作系统中，任务间通信是实现多任务协作的关键机制。FreeRTOS提供了多种通信机制，允许任务之间安全地交换数据、同步操作和协调资源访问。理解这些通信方式的特点和适用场景，对于设计高效可靠的嵌入式系统至关重要。</p>
        </section>

        <section>
            <h2>任务间通信的重要性</h2>
            <p>在FreeRTOS多任务环境中，各个任务通常是独立运行的，但它们往往需要协同工作以完成系统功能。任务间通信机制提供了以下关键功能：</p>
            <ul>
                <li><strong>数据交换</strong>：任务之间传递信息和数据</li>
                <li><strong>同步操作</strong>：协调任务执行顺序和时间</li>
                <li><strong>资源共享</strong>：安全地访问共享资源，防止竞争条件</li>
                <li><strong>事件通知</strong>：通知任务特定事件的发生</li>
            </ul>
        </section>

        <section class="architecture">
            <h2>FreeRTOS任务通信架构图</h2>
            <svg width="100%" height="400" viewBox="0 0 800 400" xmlns="http://www.w3.org/2000/svg">
                <!-- 背景 -->
                <rect x="0" y="0" width="800" height="400" fill="#e1f5fe" rx="10" ry="10"/>
                
                <!-- 任务1 -->
                <rect x="50" y="50" width="120" height="60" fill="#4fc3f7" rx="5" ry="5"/>
                <text x="110" y="85" text-anchor="middle" fill="white" font-weight="bold">任务1</text>
                
                <!-- 任务2 -->
                <rect x="50" y="150" width="120" height="60" fill="#4fc3f7" rx="5" ry="5"/>
                <text x="110" y="185" text-anchor="middle" fill="white" font-weight="bold">任务2</text>
                
                <!-- 任务3 -->
                <rect x="50" y="250" width="120" height="60" fill="#4fc3f7" rx="5" ry="5"/>
                <text x="110" y="285" text-anchor="middle" fill="white" font-weight="bold">任务3</text>
                
                <!-- 通信机制 -->
                <rect x="250" y="30" width="300" height="340" fill="#f9f9f9" rx="10" ry="10" stroke="#4fc3f7" stroke-width="2"/>
                <text x="400" y="60" text-anchor="middle" fill="#0277bd" font-weight="bold" font-size="18">FreeRTOS通信机制</text>
                
                <!-- 队列 -->
                <rect x="280" y="90" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="330" y="115" text-anchor="middle" fill="white" font-weight="bold">队列</text>
                
                <!-- 信号量 -->
                <rect x="400" y="90" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="450" y="115" text-anchor="middle" fill="white" font-weight="bold">信号量</text>
                
                <!-- 互斥量 -->
                <rect x="520" y="90" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="570" y="115" text-anchor="middle" fill="white" font-weight="bold">互斥量</text>
                
                <!-- 事件组 -->
                <rect x="280" y="150" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="330" y="175" text-anchor="middle" fill="white" font-weight="bold">事件组</text>
                
                <!-- 任务通知 -->
                <rect x="400" y="150" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="450" y="175" text-anchor="middle" fill="white" font-weight="bold">任务通知</text>
                
                <!-- 流缓冲区 -->
                <rect x="520" y="150" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="570" y="175" text-anchor="middle" fill="white" font-weight="bold">流缓冲区</text>
                
                <!-- 消息缓冲区 -->
                <rect x="400" y="210" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="450" y="235" text-anchor="middle" fill="white" font-weight="bold">消息缓冲区</text>
                
                <!-- 直接任务通知 -->
                <rect x="280" y="270" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="330" y="295" text-anchor="middle" fill="white" font-weight="bold">直接通知</text>
                
                <!-- 软件定时器 -->
                <rect x="520" y="270" width="100" height="40" fill="#81d4fa" rx="5" ry="5"/>
                <text x="570" y="295" text-anchor="middle" fill="white" font-weight="bold">软件定时器</text>
                
                <!-- 连接线 -->
                <line x1="170" y1="80" x2="250" y2="110" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="180" x2="250" y2="110" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="280" x2="250" y2="110" stroke="#4fc3f7" stroke-width="2"/>
                
                <line x1="170" y1="80" x2="250" y2="170" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="180" x2="250" y2="170" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="280" x2="250" y2="170" stroke="#4fc3f7" stroke-width="2"/>
                
                <line x1="170" y1="80" x2="250" y2="290" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="180" x2="250" y2="290" stroke="#4fc3f7" stroke-width="2"/>
                <line x1="170" y1="280" x2="250" y2="290" stroke="#4fc3f7" stroke-width="2"/>
            </svg>
        </section>

        <section>
            <h2>FreeRTOS任务间通信方式</h2>
            
            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                    </svg>
                    队列 (Queues)
                </h3>
                <p>队列是FreeRTOS中最基本也是最常用的通信机制，允许任务以FIFO（先进先出）的方式传递固定大小的数据项。</p>
                
                <h4>主要特点：</h4>
                <ul>
                    <li>数据安全传递：数据通过复制而非引用传递，避免数据竞争</li>
                    <li>多任务安全：多个任务可以同时读写队列而无需额外同步</li>
                    <li>阻塞操作：任务可以在队列操作上阻塞，等待数据可用或空间可用</li>
                    <li>超时机制：所有阻塞操作都支持超时设置</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 创建队列
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );

// 发送数据到队列
BaseType_t xQueueSend( QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait );

// 从队列接收数据
BaseType_t xQueueReceive( QueueHandle_t xQueue, void * pvBuffer, TickType_t xTicksToWait );

// 查询队列状态
UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</code></pre>
            </div>

            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M10 20h4V4h-4v16zm-6 0h4v-8H4v8zM16 9v11h4V9h-4z"/>
                    </svg>
                    信号量 (Semaphores)
                </h3>
                <p>信号量用于控制对共享资源的访问或同步任务执行。FreeRTOS提供了二进制信号量和计数信号量。</p>
                
                <h4>二进制信号量：</h4>
                <ul>
                    <li>只有两种状态：可用（满）和不可用（空）</li>
                    <li>常用于任务同步和互斥</li>
                </ul>
                
                <h4>计数信号量：</h4>
                <ul>
                    <li>可以记录多个事件的发生</li>
                    <li>常用于管理多个相同的资源</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 创建二进制信号量
SemaphoreHandle_t xSemaphoreCreateBinary( void );

// 创建计数信号量
SemaphoreHandle_t xSemaphoreCreateCounting( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount );

// 获取信号量
BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );

// 释放信号量
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );</code></pre>
            </div>

            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M17 7h-4v2h4c1.65 0 3 1.35 3 3s-1.35 3-3 3h-4v2h4c2.76 0 5-2.24 5-5s-2.24-5-5-5zm-6 8H7c-1.65 0-3-1.35-3-3s1.35-3 3-3h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-2zm-3-4h8v2H8z"/>
                    </svg>
                    互斥量 (Mutexes)
                </h3>
                <p>互斥量是一种特殊的二进制信号量，用于实现互斥访问，具有优先级继承机制，可以解决优先级反转问题。</p>
                
                <h4>主要特点：</h4>
                <ul>
                    <li>优先级继承：防止优先级反转问题</li>
                    <li>递归互斥量：同一任务可以多次获取同一个互斥量</li>
                    <li>所有权概念：只有获取互斥量的任务才能释放它</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 创建互斥量
SemaphoreHandle_t xSemaphoreCreateMutex( void );

// 创建递归互斥量
SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );

// 获取互斥量
BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait );

// 释放互斥量
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );</code></pre>
            </div>

            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                    </svg>
                    事件组 (Event Groups)
                </h3>
                <p>事件组允许任务等待多个事件中的任何一个或所有事件发生，每个事件由事件组中的一个位表示。</p>
                
                <h4>主要特点：</h4>
                <ul>
                    <li>多事件等待：任务可以等待多个事件中的任何一个或所有事件</li>
                    <li>事件清除：可以手动清除事件标志</li>
                    <li>同步多个任务：一个事件可以同步多个等待的任务</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 创建事件组
EventGroupHandle_t xEventGroupCreate( void );

// 设置事件位
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );

// 等待事件位
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, 
                                const EventBits_t uxBitsToWaitFor, 
                                BaseType_t xClearOnExit, 
                                BaseType_t xWaitForAllBits, 
                                TickType_t xTicksToWait );</code></pre>
            </div>

            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z"/>
                    </svg>
                    任务通知 (Task Notifications)
                </h3>
                <p>任务通知是FreeRTOS中一种轻量级的通信机制，可以直接向特定任务发送通知，比队列和信号量更高效。</p>
                
                <h4>主要特点：</h4>
                <ul>
                    <li>轻量高效：比队列、信号量等机制更快，占用内存更少</li>
                    <li>直接通信：直接发送给特定任务，无需中间对象</li>
                    <li>多种模式：支持二进制通知、计数通知和数值通知</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 发送任务通知
BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );

// 等待任务通知
BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, 
                           uint32_t ulBitsToClearOnExit, 
                           uint32_t *pulNotificationValue, 
                           TickType_t xTicksToWait );

// 从ISR发送任务通知
BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, 
                              uint32_t ulValue, 
                              eNotifyAction eAction, 
                              BaseType_t *pxHigherPriorityTaskWoken );</code></pre>
            </div>

            <div class="card">
                <h3>
                    <svg class="icon" viewBox="0 0 24 24" fill="#4fc3f7">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                    </svg>
                    流缓冲区和消息缓冲区
                </h3>
                <p>流缓冲区和消息缓冲区是FreeRTOS V10.0引入的新型通信机制，专门为单发送者单接收者场景优化。</p>
                
                <h4>流缓冲区 (Stream Buffers)：</h4>
                <ul>
                    <li>用于传输字节流数据</li>
                    <li>支持任意长度的数据</li>
                    <li>适用于单生产者单消费者场景</li>
                </ul>
                
                <h4>消息缓冲区 (Message Buffers)：</h4>
                <ul>
                    <li>在流缓冲区基础上增加了消息边界</li>
                    <li>每个消息都有长度信息</li>
                    <li>适用于离散消息传输</li>
                </ul>
                
                <h4>常用API函数：</h4>
                <pre><code>// 创建流缓冲区
StreamBufferHandle_t xStreamBufferCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes );

// 发送数据到流缓冲区
size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, 
                         const void *pvTxData, 
                         size_t xDataLengthBytes, 
                         TickType_t xTicksToWait );

// 从流缓冲区接收数据
size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer, 
                           void *pvRxData, 
                           size_t xBufferLengthBytes, 
                           TickType_t xTicksToWait );</code></pre>
            </div>
        </section>

        <section>
            <h2>通信机制比较</h2>
            <table>
                <thead>
                    <tr>
                        <th>通信机制</th>
                        <th>主要用途</th>
                        <th>数据传递</th>
                        <th>内存占用</th>
                        <th>性能</th>
                        <th>适用场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>队列</td>
                        <td>任务间数据交换</td>
                        <td>固定大小数据项</td>
                        <td>中等</td>
                        <td>中等</td>
                        <td>多对多通信，需要传递结构化数据</td>
                    </tr>
                    <tr>
                        <td>信号量</td>
                        <td>同步和资源管理</td>
                        <td>无数据（仅计数）</td>
                        <td>小</td>
                        <td>高</td>
                        <td>资源计数，事件同步</td>
                    </tr>
                    <tr>
                        <td>互斥量</td>
                        <td>资源互斥访问</td>
                        <td>无数据</td>
                        <td>小</td>
                        <td>高</td>
                        <td>共享资源保护，防止优先级反转</td>
                    </tr>
                    <tr>
                        <td>事件组</td>
                        <td>多事件同步</td>
                        <td>事件标志位</td>
                        <td>很小</td>
                        <td>高</td>
                        <td>等待多个事件，广播通知</td>
                    </tr>
                    <tr>
                        <td>任务通知</td>
                        <td>轻量级任务通信</td>
                        <td>32位值或标志</td>
                        <td>极小</td>
                        <td>非常高</td>
                        <td>单对单通信，替代二进制信号量</td>
                    </tr>
                    <tr>
                        <td>流/消息缓冲区</td>
                        <td>流数据或消息传输</td>
                        <td>字节流或消息</td>
                        <td>中等</td>
                        <td>高</td>
                        <td>单生产者单消费者，流数据传输</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>选择通信机制的建议</h2>
            <div class="comparison">
                <div class="comparison-item">
                    <h3>数据传递需求</h3>
                    <ul>
                        <li><strong>需要传递数据</strong>：使用队列、流缓冲区或消息缓冲区</li>
                        <li><strong>仅需同步</strong>：使用信号量、事件组或任务通知</li>
                        <li><strong>保护共享资源</strong>：使用互斥量</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h3>性能考虑</h3>
                    <ul>
                        <li><strong>最高性能</strong>：任务通知（比二进制信号量快45%）</li>
                        <li><strong>中等性能</strong>：队列、信号量、互斥量</li>
                        <li><strong>流数据传输</strong>：流缓冲区或消息缓冲区</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h3>通信模式</h3>
                    <ul>
                        <li><strong>一对一通信</strong>：任务通知、流/消息缓冲区</li>
                        <li><strong>一对多通信</strong>：队列、事件组</li>
                        <li><strong>多对多通信</strong>：队列</li>
                    </ul>
                </div>
            </div>
        </section>

        <section>
            <h2>实际应用示例</h2>
            <div class="card">
                <h3>使用队列传递传感器数据</h3>
                <pre><code>// 定义数据结构
typedef struct {
    float temperature;
    float humidity;
    uint32_t timestamp;
} SensorData_t;

// 创建队列
QueueHandle_t xSensorQueue = xQueueCreate(10, sizeof(SensorData_t));

// 传感器任务发送数据
void vSensorTask(void *pvParameters) {
    SensorData_t data;
    while(1) {
        // 读取传感器数据
        data.temperature = readTemperature();
        data.humidity = readHumidity();
        data.timestamp = xTaskGetTickCount();
        
        // 发送到队列
        if(xQueueSend(xSensorQueue, &data, portMAX_DELAY) != pdPASS) {
            // 处理发送失败
        }
        
        vTaskDelay(pdMS_TO_TICKS(1000)); // 每秒发送一次
    }
}

// 处理任务接收数据
void vProcessingTask(void *pvParameters) {
    SensorData_t receivedData;
    while(1) {
        // 从队列接收数据
        if(xQueueReceive(xSensorQueue, &receivedData, portMAX_DELAY) == pdPASS) {
            // 处理接收到的数据
            processSensorData(&receivedData);
        }
    }
}</code></pre>
            </div>

            <div class="card">
                <h3>使用事件组进行多任务同步</h3>
                <pre><code>// 定义事件标志位
#define TEMP_READY_BIT (1 << 0)
#define HUMID_READY_BIT (1 << 1)
#define PRESSURE_READY_BIT (1 << 2)
#define ALL_SENSORS_READY (TEMP_READY_BIT | HUMID_READY_BIT | PRESSURE_READY_BIT)

// 创建事件组
EventGroupHandle_t xSensorEventGroup = xEventGroupCreate();

// 温度传感器任务
void vTemperatureTask(void *pvParameters) {
    while(1) {
        readTemperature();
        // 设置温度就绪标志
        xEventGroupSetBits(xSensorEventGroup, TEMP_READY_BIT);
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// 数据处理任务等待所有传感器就绪
void vDataProcessingTask(void *pvParameters) {
    EventBits_t uxBits;
    while(1) {
        // 等待所有传感器数据就绪
        uxBits = xEventGroupWaitBits(
            xSensorEventGroup,           // 事件组句柄
            ALL_SENSORS_READY,           // 等待的位
            pdTRUE,                      // 退出时清除这些位
            pdTRUE,                      // 等待所有位
            portMAX_DELAY                // 无限期等待
        );
        
        if((uxBits & ALL_SENSORS_READY) == ALL_SENSORS_READY) {
            // 所有传感器数据就绪，进行处理
            processAllSensorData();
        }
    }
}</code></pre>
            </div>
        </section>

        <section>
            <h2>总结</h2>
            <div class="card">
                <p>FreeRTOS提供了丰富多样的任务间通信机制，每种机制都有其特定的应用场景和优势：</p>
                <ul>
                    <li><strong>队列</strong>是最通用的通信机制，适用于大多数数据传递场景</li>
                    <li><strong>信号量和互斥量</strong>专注于同步和资源保护</li>
                    <li><strong>事件组</strong>适合多事件等待和广播通知</li>
                    <li><strong>任务通知</strong>提供了最高效的轻量级通信</li>
                    <li><strong>流/消息缓冲区</strong>针对单生产者单消费者场景优化</li>
                </ul>
                <p>在实际项目中，应根据具体需求选择合适的通信机制，考虑因素包括：数据传递需求、性能要求、内存限制、通信模式等。合理使用这些通信机制可以构建出高效、可靠的嵌入式多任务系统。</p>
            </div>
        </section>

        <footer>
            <p>蓝海资料掘金营</p>
        </footer>
    </div>
</body>
</html>