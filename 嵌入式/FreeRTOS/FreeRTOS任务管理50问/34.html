<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeRTOS任务死锁预防</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #f9fbe7 50%, #e8f5e9 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            border: 2px solid #4db6ac;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px dashed #4db6ac;
        }

        h1 {
            color: #00695c;
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #00796b;
            font-size: 1.8rem;
            margin: 25px 0 15px;
            padding-left: 10px;
            border-left: 5px solid #4db6ac;
        }

        h3 {
            color: #00897b;
            font-size: 1.4rem;
            margin: 20px 0 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .highlight-box {
            background-color: #e0f2f1;
            border-left: 5px solid #004d40;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .code-block {
            background-color: #f5f5f5;
            border: 1px solid #b2dfdb;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            color: #00695c;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #f1f8e9;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #c8e6c9;
        }

        th {
            background-color: #4db6ac;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #e8f5e9;
        }

        tr:hover {
            background-color: #c8e6c9;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 8px;
        }

        .svg-container {
            display: flex;
            justify-content: center;
            margin: 25px 0;
        }

        .comparison {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .comparison-item {
            flex: 1;
            min-width: 300px;
            margin: 10px;
            padding: 20px;
            background-color: #e8f5e9;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #00695c;
            font-weight: bold;
            border-top: 2px dashed #4db6ac;
        }

        .tip {
            background-color: #fff9c4;
            border: 1px solid #ffd54f;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .warning {
            background-color: #ffebee;
            border: 1px solid #e57373;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FreeRTOS任务死锁预防</h1>
            <p>如何避免任务间的死锁 - 《FreeRTOS任务管理50问》第34问</p>
        </header>

        <section>
            <h2>什么是任务死锁？</h2>
            <p>在FreeRTOS多任务环境中，死锁是指两个或多个任务无限期地等待对方释放资源而无法继续执行的状态。死锁通常发生在任务需要同时获取多个共享资源时。</p>
            
            <div class="svg-container">
                <svg width="500" height="200" viewBox="0 0 500 200">
                    <rect x="50" y="50" width="100" height="60" rx="10" fill="#4db6ac" stroke="#00796b" stroke-width="2"/>
                    <text x="100" y="85" text-anchor="middle" fill="white" font-weight="bold">任务A</text>
                    
                    <rect x="350" y="50" width="100" height="60" rx="10" fill="#4db6ac" stroke="#00796b" stroke-width="2"/>
                    <text x="400" y="85" text-anchor="middle" fill="white" font-weight="bold">任务B</text>
                    
                    <rect x="150" y="30" width="60" height="40" rx="5" fill="#ffb74d" stroke="#f57c00" stroke-width="2"/>
                    <text x="180" y="55" text-anchor="middle" fill="white" font-size="12">资源1</text>
                    
                    <rect x="290" y="30" width="60" height="40" rx="5" fill="#ffb74d" stroke="#f57c00" stroke-width="2"/>
                    <text x="320" y="55" text-anchor="middle" fill="white" font-size="12">资源2</text>
                    
                    <line x1="150" y1="70" x2="100" y2="110" stroke="#e53935" stroke-width="2" stroke-dasharray="5,5"/>
                    <line x1="290" y1="70" x2="400" y2="110" stroke="#e53935" stroke-width="2" stroke-dasharray="5,5"/>
                    
                    <line x1="210" y1="70" x2="350" y2="110" stroke="#e53935" stroke-width="2" stroke-dasharray="5,5"/>
                    <line x1="350" y1="70" x2="150" y2="110" stroke="#e53935" stroke-width="2" stroke-dasharray="5,5"/>
                    
                    <text x="250" y="150" text-anchor="middle" fill="#d32f2f" font-weight="bold">死锁形成示意图</text>
                </svg>
            </div>
            
            <div class="highlight-box">
                <p><strong>死锁的四个必要条件：</strong></p>
                <ol>
                    <li><strong>互斥条件</strong>：资源不能被共享，只能由一个任务使用</li>
                    <li><strong>占有且等待</strong>：任务持有至少一个资源，同时等待获取其他任务持有的资源</li>
                    <li><strong>不可抢占</strong>：资源只能由持有它的任务自愿释放</li>
                    <li><strong>循环等待</strong>：存在一个任务等待序列，每个任务都在等待下一个任务所持有的资源</li>
                </ol>
            </div>
        </section>

        <section>
            <h2>FreeRTOS中常见的死锁场景</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>场景类型</th>
                        <th>描述</th>
                        <th>风险等级</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>互斥锁嵌套</td>
                        <td>任务尝试以不同顺序获取多个互斥锁</td>
                        <td>高</td>
                    </tr>
                    <tr>
                        <td>信号量误用</td>
                        <td>二进制信号量与互斥锁混淆使用</td>
                        <td>中</td>
                    </tr>
                    <tr>
                        <td>递归互斥锁</td>
                        <td>递归互斥锁使用不当导致自死锁</td>
                        <td>中</td>
                    </tr>
                    <tr>
                        <td>队列阻塞</td>
                        <td>任务相互等待对方发送队列消息</td>
                        <td>中</td>
                    </tr>
                    <tr>
                        <td>优先级反转</td>
                        <td>低优先级任务持有高优先级任务需要的资源</td>
                        <td>高</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h2>死锁预防策略</h2>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h3>1. 资源排序法</h3>
                    <p>为所有资源定义全局顺序，要求所有任务按照相同顺序获取资源。</p>
                    <div class="code-block">
<pre>
// 定义资源获取顺序
#define RESOURCE_ORDER_MUTEX  1
#define RESOURCE_ORDER_SEM    2
#define RESOURCE_ORDER_QUEUE  3

// 正确的资源获取顺序
xSemaphoreTake(mutex1, portMAX_DELAY);  // 顺序1
xSemaphoreTake(sem1, portMAX_DELAY);    // 顺序2
xQueueSend(queue1, &data, portMAX_DELAY); // 顺序3
</pre>
                    </div>
                </div>
                
                <div class="comparison-item">
                    <h3>2. 超时机制</h3>
                    <p>为资源获取操作设置合理的超时时间，避免无限期等待。</p>
                    <div class="code-block">
<pre>
// 设置超时避免死锁
const TickType_t timeout = pdMS_TO_TICKS(1000); // 1秒超时

if(xSemaphoreTake(mutex, timeout) == pdTRUE) {
    // 成功获取资源
    // 执行关键操作
    xSemaphoreGive(mutex);
} else {
    // 超时处理
    // 释放已持有资源，执行错误恢复
}
</pre>
                    </div>
                </div>
            </div>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h3>3. 避免嵌套锁</h3>
                    <p>尽量减少锁的嵌套使用，或使用递归互斥锁处理嵌套情况。</p>
                    <div class="code-block">
<pre>
// 使用递归互斥锁避免自死锁
SemaphoreHandle_t recursive_mutex;

void task_function(void *pvParameters) {
    // 第一次获取
    xSemaphoreTakeRecursive(recursive_mutex, portMAX_DELAY);
    
    // 嵌套调用中再次获取
    nested_function();
    
    // 释放次数与获取次数相同
    xSemaphoreGiveRecursive(recursive_mutex);
}

void nested_function(void) {
    xSemaphoreTakeRecursive(recursive_mutex, portMAX_DELAY);
    // 执行操作
    xSemaphoreGiveRecursive(recursive_mutex);
}
</pre>
                    </div>
                </div>
                
                <div class="comparison-item">
                    <h3>4. 优先级继承</h3>
                    <p>使用支持优先级继承的互斥锁，防止优先级反转导致的死锁。</p>
                    <div class="code-block">
<pre>
// 创建支持优先级继承的互斥锁
SemaphoreHandle_t xMutex;

void create_mutex_with_priority_inheritance(void) {
    xMutex = xSemaphoreCreateMutex();
    
    // FreeRTOS 互斥锁默认支持优先级继承
    // 确保configUSE_MUTEXES在FreeRTOSConfig.h中设置为1
}

// 任务使用互斥锁
void high_priority_task(void *pvParameters) {
    while(1) {
        if(xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE) {
            // 访问共享资源
            xSemaphoreGive(xMutex);
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
</pre>
                    </div>
                </div>
            </div>
        </section>

        <section>
            <h2>FreeRTOS死锁检测与调试</h2>
            
            <div class="svg-container">
                <svg width="600" height="300" viewBox="0 0 600 300">
                    <rect x="50" y="50" width="500" height="200" rx="10" fill="#e3f2fd" stroke="#2196f3" stroke-width="2"/>
                    
                    <rect x="80" y="80" width="120" height="40" rx="5" fill="#bbdefb" stroke="#2196f3" stroke-width="1"/>
                    <text x="140" y="105" text-anchor="middle" fill="#0d47a1" font-size="14">启用调试宏</text>
                    
                    <rect x="80" y="140" width="120" height="40" rx="5" fill="#bbdefb" stroke="#2196f3" stroke-width="1"/>
                    <text x="140" y="165" text-anchor="middle" fill="#0d47a1" font-size="14">使用Trace工具</text>
                    
                    <rect x="240" y="80" width="120" height="40" rx="5" fill="#bbdefb" stroke="#2196f3" stroke-width="1"/>
                    <text x="300" y="105" text-anchor="middle" fill="#0d47a1" font-size="14">钩子函数监控</text>
                    
                    <rect x="240" y="140" width="120" height="40" rx="5" fill="#bbdefb" stroke="#2196f3" stroke-width="1"/>
                    <text x="300" y="165" text-anchor="middle" fill="#0d47a1" font-size="14">堆栈使用分析</text>
                    
                    <rect x="400" y="110" width="120" height="40" rx="5" fill="#bbdefb" stroke="#2196f3" stroke-width="1"/>
                    <text x="460" y="135" text-anchor="middle" fill="#0d47a1" font-size="14">运行时断言</text>
                    
                    <line x1="200" y1="100" x2="240" y2="100" stroke="#2196f3" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="200" y1="160" x2="240" y2="160" stroke="#2196f3" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="360" y1="100" x2="400" y2="120" stroke="#2196f3" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <line x1="360" y1="160" x2="400" y2="140" stroke="#2196f3" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#2196f3"/>
                        </marker>
                    </defs>
                    
                    <text x="300" y="240" text-anchor="middle" fill="#0d47a1" font-weight="bold">FreeRTOS死锁检测方法</text>
                </svg>
            </div>
            
            <div class="tip">
                <p><strong>调试技巧：</strong>在FreeRTOSConfig.h中启用以下配置宏，可以增强死锁检测能力：</p>
                <ul>
                    <li><code>configUSE_TRACE_FACILITY</code> - 启用跟踪功能</li>
                    <li><code>configUSE_MUTEX</code> - 启用互斥锁功能</li>
                    <li><code>configCHECK_FOR_STACK_OVERFLOW</code> - 检查堆栈溢出</li>
                    <li><code>configUSE_APPLICATION_TASK_TAG</code> - 任务标签用于调试</li>
                </ul>
            </div>
            
            <div class="code-block">
<pre>
// FreeRTOSConfig.h 中的关键配置
#define configUSE_TRACE_FACILITY         1
#define configUSE_MUTEX                  1
#define configUSE_RECURSIVE_MUTEX        1
#define configUSE_COUNTING_SEMAPHORES    1
#define configCHECK_FOR_STACK_OVERFLOW   2
#define configUSE_MALLOC_FAILED_HOOK     1
#define configUSE_APPLICATION_TASK_TAG   1

// 使用钩子函数监控任务状态
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
    // 堆栈溢出处理
    while(1); // 或执行系统复位
}

void vApplicationMallocFailedHook(void) {
    // 内存分配失败处理
    while(1);
}
</pre>
            </div>
        </section>

        <section>
            <h2>最佳实践总结</h2>
            
            <div class="highlight-box">
                <p><strong>预防死锁的黄金法则：</strong></p>
                <ol>
                    <li><strong>统一资源获取顺序</strong>：所有任务按照相同顺序获取资源</li>
                    <li><strong>设置合理超时</strong>：避免无限期等待资源</li>
                    <li><strong>最小化锁持有时间</strong>：尽快释放已获取的资源</li>
                    <li><strong>使用优先级继承</strong>：防止优先级反转</li>
                    <li><strong>避免不必要的锁嵌套</strong>：简化资源管理逻辑</li>
                    <li><strong>充分的测试</strong>：在各种负载条件下测试系统</li>
                </ol>
            </div>
            
            <div class="warning">
                <p><strong>注意事项：</strong>死锁问题往往在系统高负载或特定时序条件下才会暴露，因此在开发阶段就需要建立完善的预防机制，而不是等到问题出现后再解决。</p>
            </div>
        </section>

        <footer>
            <p>蓝海资料掘金营</p>
        </footer>
    </div>
</body>
</html>