<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蓝牙厂商扩展 - Linux内核蓝牙驱动开发实战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #f9fbe7 50%, #e8f5e9 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 30px;
            position: relative;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #4db6ac;
        }

        .header h1 {
            color: #00695c;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }

        .header p {
            color: #00796b;
            font-size: 1.2rem;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }

        .section-title {
            color: #004d40;
            font-size: 1.8rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #80cbc4;
        }

        .subsection {
            margin-bottom: 25px;
        }

        .subsection-title {
            color: #00796b;
            font-size: 1.4rem;
            margin-bottom: 15px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #b2dfdb;
        }

        th {
            background-color: #4db6ac;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #e0f2f1;
        }

        tr:hover {
            background-color: #b2dfdb;
        }

        .code-block {
            background-color: #f5f5f5;
            border-left: 4px solid #4db6ac;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            overflow-x: auto;
        }

        pre {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .svg-container {
            text-align: center;
            margin: 25px 0;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        .footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #00796b;
            font-size: 1.1rem;
            border-top: 2px solid #80cbc4;
        }

        .highlight {
            background-color: #fff9c4;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .note {
            background-color: #e1f5fe;
            border-left: 4px solid #0288d1;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .warning {
            background-color: #ffecb3;
            border-left: 4px solid #ffa000;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>蓝牙厂商扩展：厂商特定命令、私有协议实现、兼容性处理</h1>
            <p>《Linux内核蓝牙驱动开发实战》课程 - 第35讲</p>
        </div>

        <div class="section">
            <h2 class="section-title">概述</h2>
            <p>蓝牙技术作为无线通信的重要标准，在标准化协议之外，各厂商通常会实现自己的扩展功能。这些扩展包括厂商特定命令、私有协议实现以及兼容性处理，是蓝牙驱动开发中的重要组成部分。</p>
            <p>在本课程中，我们将深入探讨如何在Linux内核中实现蓝牙厂商扩展，包括如何添加厂商特定命令、实现私有协议以及处理不同厂商设备间的兼容性问题。</p>
        </div>

        <div class="section">
            <h2 class="section-title">厂商特定命令</h2>
            
            <div class="subsection">
                <h3 class="subsection-title">厂商特定命令概述</h3>
                <p>厂商特定命令是蓝牙标准允许厂商实现的非标准命令，用于提供设备特定的功能扩展。这些命令通常以厂商特定的操作码(OpCode)开头，遵循特定的格式。</p>
                
                <div class="svg-container">
                    <svg width="800" height="200" viewBox="0 0 800 200">
                        <rect x="10" y="50" width="780" height="100" fill="#e1f5fe" stroke="#4db6ac" stroke-width="2"/>
                        <rect x="20" y="60" width="100" height="80" fill="#4db6ac" stroke="#00796b" stroke-width="2"/>
                        <text x="70" y="105" text-anchor="middle" fill="white" font-size="14">OpCode Group</text>
                        <rect x="130" y="60" width="100" height="80" fill="#80cbc4" stroke="#00796b" stroke-width="2"/>
                        <text x="180" y="105" text-anchor="middle" fill="white" font-size="14">厂商ID</text>
                        <rect x="240" y="60" width="100" height="80" fill="#b2dfdb" stroke="#00796b" stroke-width="2"/>
                        <text x="290" y="105" text-anchor="middle" fill="white" font-size="14">命令码</text>
                        <rect x="350" y="60" width="430" height="80" fill="#e0f2f1" stroke="#00796b" stroke-width="2"/>
                        <text x="565" y="105" text-anchor="middle" fill="#00796b" font-size="14">厂商特定参数</text>
                        
                        <text x="70" y="40" text-anchor="middle" fill="#004d40" font-size="12">2字节</text>
                        <text x="180" y="40" text-anchor="middle" fill="#004d40" font-size="12">2字节</text>
                        <text x="290" y="40" text-anchor="middle" fill="#004d40" font-size="12">1字节</text>
                        <text x="565" y="40" text-anchor="middle" fill="#004d40" font-size="12">变长</text>
                    </svg>
                </div>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">厂商特定命令实现</h3>
                <p>在Linux内核中，厂商特定命令通常通过HCI（Host Controller Interface）层实现。以下是一个示例代码，展示如何发送厂商特定命令：</p>
                
                <div class="code-block">
                    <pre><code>#include &lt;linux/bluetooth.h&gt;
#include &lt;net/bluetooth/hci_core.h&gt;

/* 定义厂商特定命令结构 */
struct vendor_cmd {
    __le16 opcode;      /* 操作码 */
    __u8 plen;          /* 参数长度 */
    __u8 params[];      /* 参数 */
} __packed;

/* 发送厂商特定命令函数 */
static int send_vendor_specific_cmd(struct hci_dev *hdev, 
                                   __u16 opcode, 
                                   __u8 plen, 
                                   void *param)
{
    struct sk_buff *skb;
    struct vendor_cmd *cmd;
    
    /* 分配SKB缓冲区 */
    skb = bt_skb_alloc(sizeof(*cmd) + plen, GFP_ATOMIC);
    if (!skb)
        return -ENOMEM;
    
    /* 构建命令 */
    cmd = skb_put(skb, sizeof(*cmd) + plen);
    cmd->opcode = cpu_to_le16(opcode);
    cmd->plen = plen;
    
    if (plen > 0 && param)
        memcpy(cmd->params, param, plen);
    
    /* 设置命令完成回调 */
    hci_skb_pkt_type(skb) = HCI_COMMAND_PKT;
    
    /* 发送命令 */
    return hci_send_cmd(hdev, skb);
}

/* 厂商特定命令处理函数 */
static void vendor_cmd_complete(struct hci_dev *hdev, 
                               struct sk_buff *skb)
{
    struct hci_ev_cmd_complete *evt;
    __u16 opcode;
    
    if (!skb || skb->len < sizeof(*evt))
        return;
    
    evt = (void *)skb->data;
    opcode = __le16_to_cpu(evt->opcode);
    
    /* 处理不同的厂商命令完成事件 */
    switch (opcode) {
    case VENDOR_CMD_OPCODE_1:
        /* 处理命令1完成 */
        break;
    case VENDOR_CMD_OPCODE_2:
        /* 处理命令2完成 */
        break;
    default:
        break;
    }
}</code></pre>
                </div>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">常见厂商特定命令</h3>
                <table>
                    <thead>
                        <tr>
                            <th>厂商</th>
                            <th>命令类型</th>
                            <th>功能描述</th>
                            <th>OpCode范围</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Broadcom</td>
                            <td>诊断命令</td>
                            <td>固件调试和诊断功能</td>
                            <td>0xFC00-0xFCFF</td>
                        </tr>
                        <tr>
                            <td>Qualcomm</td>
                            <td>增强功能</td>
                            <td>功耗优化和性能增强</td>
                            <td>0xFD00-0xFDFF</td>
                        </tr>
                        <tr>
                            <td>Intel</td>
                            <td>配置命令</td>
                            <td>硬件特定配置</td>
                            <td>0xFE00-0xFEFF</td>
                        </tr>
                        <tr>
                            <td>其他厂商</td>
                            <td>私有功能</td>
                            <td>厂商特定功能扩展</td>
                            <td>0xFF00-0xFFFF</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">私有协议实现</h2>
            
            <div class="subsection">
                <h3 class="subsection-title">私有协议架构</h3>
                <p>私有协议是厂商在标准蓝牙协议栈之上实现的专有通信协议，通常用于提供标准协议不支持的高级功能。</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400">
                        <!-- 应用层 -->
                        <rect x="50" y="30" width="600" height="50" fill="#e1f5fe" stroke="#4db6ac" stroke-width="2"/>
                        <text x="350" y="60" text-anchor="middle" fill="#004d40" font-size="16" font-weight="bold">应用层</text>
                        
                        <!-- 厂商私有协议层 -->
                        <rect x="100" y="100" width="500" height="50" fill="#c8e6c9" stroke="#388e3c" stroke-width="2"/>
                        <text x="350" y="130" text-anchor="middle" fill="#004d40" font-size="16" font-weight="bold">厂商私有协议层</text>
                        
                        <!-- 标准蓝牙协议栈 -->
                        <rect x="150" y="170" width="400" height="150" fill="#fff9c4" stroke="#f57c00" stroke-width="2"/>
                        <text x="350" y="190" text-anchor="middle" fill="#004d40" font-size="14" font-weight="bold">标准蓝牙协议栈</text>
                        
                        <!-- 协议栈内部层次 -->
                        <rect x="170" y="210" width="360" height="25" fill="#ffecb3" stroke="#ffa000" stroke-width="1"/>
                        <text x="350" y="227" text-anchor="middle" fill="#004d40" font-size="12">RFCOMM/L2CAP</text>
                        
                        <rect x="170" y="240" width="360" height="25" fill="#ffe0b2" stroke="#ff8f00" stroke-width="1"/>
                        <text x="350" y="257" text-anchor="middle" fill="#004d40" font-size="12">HCI</text>
                        
                        <rect x="170" y="270" width="360" height="25" fill="#ffccbc" stroke="#ff6d00" stroke-width="1"/>
                        <text x="350" y="287" text-anchor="middle" fill="#004d40" font-size="12">Baseband/LL</text>
                        
                        <!-- 连接线 -->
                        <line x1="350" y1="80" x2="350" y2="100" stroke="#4db6ac" stroke-width="2"/>
                        <line x1="350" y1="150" x2="350" y2="170" stroke="#4db6ac" stroke-width="2"/>
                        
                        <!-- 旁注 -->
                        <text x="650" y="130" text-anchor="start" fill="#d84315" font-size="12">厂商扩展功能</text>
                        <line x1="610" y1="125" x2="650" y2="125" stroke="#d84315" stroke-width="1"/>
                        
                        <text x="50" y="320" text-anchor="start" fill="#d84315" font-size="12">标准蓝牙功能</text>
                        <line x1="150" y1="315" x2="50" y2="315" stroke="#d84315" stroke-width="1"/>
                    </svg>
                </div>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">私有协议实现示例</h3>
                <p>以下代码展示了如何在Linux内核中实现一个简单的私有协议：</p>
                
                <div class="code-block">
                    <pre><code>/* 私有协议头定义 */
struct vendor_protocol_header {
    __u8 start_flag;        /* 起始标志 */
    __le16 vendor_id;       /* 厂商ID */
    __u8 protocol_version;  /* 协议版本 */
    __le16 data_length;     /* 数据长度 */
    __u8 command_id;        /* 命令ID */
    __u8 checksum;          /* 校验和 */
} __packed;

/* 私有协议命令定义 */
enum vendor_protocol_commands {
    VENDOR_CMD_GET_INFO = 0x01,
    VENDOR_CMD_SET_CONFIG = 0x02,
    VENDOR_CMD_START_TEST = 0x03,
    VENDOR_CMD_GET_RESULT = 0x04,
};

/* 私有协议处理函数 */
static int vendor_protocol_process(struct hci_dev *hdev, 
                                  struct sk_buff *skb)
{
    struct vendor_protocol_header *hdr;
    __u8 *data;
    int ret = 0;
    
    if (!skb || skb->len < sizeof(*hdr))
        return -EINVAL;
    
    hdr = (struct vendor_protocol_header *)skb->data;
    
    /* 验证起始标志 */
    if (hdr->start_flag != VENDOR_START_FLAG)
        return -EINVAL;
    
    /* 验证校验和 */
    if (calculate_checksum(skb->data, skb->len) != hdr->checksum)
        return -EINVAL;
    
    data = skb->data + sizeof(*hdr);
    
    /* 根据命令ID处理不同命令 */
    switch (hdr->command_id) {
    case VENDOR_CMD_GET_INFO:
        ret = handle_get_info(hdev, data, 
                             le16_to_cpu(hdr->data_length));
        break;
        
    case VENDOR_CMD_SET_CONFIG:
        ret = handle_set_config(hdev, data, 
                               le16_to_cpu(hdr->data_length));
        break;
        
    case VENDOR_CMD_START_TEST:
        ret = handle_start_test(hdev, data, 
                               le16_to_cpu(hdr->data_length));
        break;
        
    case VENDOR_CMD_GET_RESULT:
        ret = handle_get_result(hdev, data, 
                               le16_to_cpu(hdr->data_length));
        break;
        
    default:
        bt_dev_dbg(hdev, "Unknown vendor command: 0x%02x", 
                   hdr->command_id);
        ret = -EOPNOTSUPP;
        break;
    }
    
    return ret;
}

/* 发送私有协议响应 */
static int send_vendor_protocol_response(struct hci_dev *hdev,
                                        __u8 command_id,
                                        const void *data,
                                        __u16 data_len)
{
    struct sk_buff *skb;
    struct vendor_protocol_header *hdr;
    int total_len = sizeof(*hdr) + data_len;
    
    skb = bt_skb_alloc(total_len, GFP_KERNEL);
    if (!skb)
        return -ENOMEM;
    
    hdr = skb_put(skb, total_len);
    hdr->start_flag = VENDOR_START_FLAG;
    hdr->vendor_id = cpu_to_le16(VENDOR_ID);
    hdr->protocol_version = PROTOCOL_VERSION;
    hdr->data_length = cpu_to_le16(data_len);
    hdr->command_id = command_id | 0x80; /* 设置响应标志 */
    
    if (data_len > 0 && data)
        memcpy(hdr + 1, data, data_len);
    
    hdr->checksum = calculate_checksum(skb->data, total_len - 1);
    
    return hci_send_acl(hdev, skb, 0);
}</code></pre>
                </div>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">兼容性处理</h2>
            
            <div class="subsection">
                <h3 class="subsection-title">兼容性挑战</h3>
                <p>在实现蓝牙厂商扩展时，面临的主要兼容性挑战包括：</p>
                <ul>
                    <li><span class="highlight">不同厂商设备的互操作性</span> - 不同厂商实现的扩展功能可能不兼容</li>
                    <li><span class="highlight">固件版本差异</span> - 同一厂商不同固件版本可能支持不同的扩展功能</li>
                    <li><span class="highlight">操作系统差异</span> - 不同操作系统对厂商扩展的支持程度不同</li>
                    <li><span class="highlight">协议版本兼容</span> - 新旧协议版本之间的兼容性问题</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">兼容性处理策略</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>兼容性问题</th>
                            <th>检测方法</th>
                            <th>处理策略</th>
                            <th>回退方案</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>厂商命令支持</td>
                            <td>发送探测命令并检查响应</td>
                            <td>动态检测功能支持情况</td>
                            <td>使用标准命令替代</td>
                        </tr>
                        <tr>
                            <td>协议版本兼容</td>
                            <td>读取版本信息并比较</td>
                            <td>根据版本选择适当功能集</td>
                            <td>使用最低通用版本</td>
                        </tr>
                        <tr>
                            <td>固件功能差异</td>
                            <td>查询固件能力和特性</td>
                            <td>功能特性位掩码检测</td>
                            <td>禁用不支持的功能</td>
                        </tr>
                        <tr>
                            <td>性能特性差异</td>
                            <td>基准测试和性能分析</td>
                            <td>自适应参数调整</td>
                            <td>使用保守的默认值</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">兼容性处理代码示例</h3>
                
                <div class="code-block">
                    <pre><code>/* 兼容性检测结构 */
struct compatibility_info {
    __le16 vendor_id;
    __u8 hci_version;
    __le16 hci_revision;
    __u8 lmp_version;
    __le16 lmp_subversion;
    __u32 supported_features;
    __u32 extended_features[8];
};

/* 兼容性检测函数 */
static int check_device_compatibility(struct hci_dev *hdev,
                                     struct compatibility_info *info)
{
    int err;
    
    /* 读取本地版本信息 */
    err = read_local_version(hdev, info);
    if (err)
        return err;
    
    /* 读取本地支持的特性 */
    err = read_local_features(hdev, info);
    if (err)
        return err;
    
    /* 根据设备信息确定兼容性级别 */
    return determine_compatibility_level(hdev, info);
}

/* 功能检测函数 */
static bool check_vendor_feature_support(struct hci_dev *hdev,
                                        __u32 feature_mask)
{
    struct compatibility_info info;
    int err;
    
    err = check_device_compatibility(hdev, &info);
    if (err)
        return false;
    
    /* 检查是否支持特定厂商功能 */
    return (info.supported_features & feature_mask) == feature_mask;
}

/* 自适应功能启用 */
static int enable_vendor_features_adaptively(struct hci_dev *hdev)
{
    struct compatibility_info info;
    int err;
    
    err = check_device_compatibility(hdev, &info);
    if (err)
        return err;
    
    /* 根据兼容性信息选择性启用功能 */
    if (check_vendor_feature_support(hdev, VENDOR_FEATURE_A)) {
        err = enable_feature_a(hdev);
        if (err)
            bt_dev_warn(hdev, "Failed to enable feature A");
    }
    
    if (check_vendor_feature_support(hdev, VENDOR_FEATURE_B)) {
        err = enable_feature_b(hdev);
        if (err)
            bt_dev_warn(hdev, "Failed to enable feature B");
    }
    
    /* 设置回退到标准功能 */
    setup_fallback_to_standard(hdev);
    
    return 0;
}

/* 版本特定的命令发送 */
static int send_version_specific_command(struct hci_dev *hdev,
                                        __u16 base_opcode,
                                        const void *param,
                                        __u8 plen)
{
    struct compatibility_info info;
    __u16 actual_opcode = base_opcode;
    int err;
    
    err = check_device_compatibility(hdev, &info);
    if (err)
        return err;
    
    /* 根据版本调整命令 */
    if (info.hci_version >= 0x08) {
        /* 新版本使用扩展命令 */
        actual_opcode |= 0x0100;
    }
    
    return send_vendor_specific_cmd(hdev, actual_opcode, plen, param);
}</code></pre>
                </div>
            </div>
            
            <div class="note">
                <p><strong>注意：</strong>兼容性处理是蓝牙驱动开发中的关键环节。良好的兼容性处理可以显著提高驱动程序的稳定性和用户体验。</p>
            </div>
            
            <div class="warning">
                <p><strong>警告：</strong>在实现厂商扩展时，务必确保在功能不可用时有适当的回退机制，避免因兼容性问题导致设备无法正常工作。</p>
            </div>
        </div>

        <div class="section">
            <h2 class="section-title">最佳实践</h2>
            
            <div class="subsection">
                <h3 class="subsection-title">开发建议</h3>
                <ol>
                    <li><span class="highlight">渐进式功能启用</span> - 逐步检测和启用扩展功能，确保基本功能始终可用</li>
                    <li><span class="highlight">完善的错误处理</span> - 对所有厂商命令实现完整的错误处理机制</li>
                    <li><span class="highlight">版本兼容性矩阵</span> - 维护设备版本与功能支持的兼容性矩阵</li>
                    <li><span class="highlight">充分的测试覆盖</span> - 针对不同厂商设备和固件版本进行充分测试</li>
                    <li><span class="highlight">文档完整性</span> - 详细记录厂商扩展的实现细节和兼容性信息</li>
                </ol>
            </div>
            
            <div class="subsection">
                <h3 class="subsection-title">调试技巧</h3>
                <ul>
                    <li>使用 <code>hcidump</code> 和 <code>btmon</code> 工具监控HCI流量</li>
                    <li>在内核中增加详细的调试日志，便于问题定位</li>
                    <li>实现厂商特定的诊断命令，用于调试和故障排除</li>
                    <li>使用仿真环境测试兼容性处理逻辑</li>
                </ul>
            </div>
        </div>

        <div class="footer">
            <p>蓝海资料掘金营</p>
        </div>
    </div>
</body>
</html>