<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蓝牙USB传输驱动开发实战</title>
    <style>
        :root {
            --primary: #4CAF50;
            --secondary: #FFC107;
            --accent: #2196F3;
            --light: #E8F5E9;
            --dark: #2E7D32;
            --text: #333333;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--light) 0%, #FFFFFF 100%);
            color: var(--text);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 15px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        h2 {
            color: var(--dark);
            border-left: 5px solid var(--secondary);
            padding-left: 15px;
            margin-top: 2rem;
        }
        
        h3 {
            color: var(--accent);
            margin-top: 1.5rem;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.05);
        }
        
        .code-block {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }
        
        th {
            background-color: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .svg-container {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        footer {
            text-align: center;
            margin-top: 3rem;
            padding: 1.5rem;
            background: linear-gradient(90deg, var(--dark) 0%, var(--primary) 100%);
            color: white;
            border-radius: 15px;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        .highlight {
            background-color: var(--secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .note {
            background-color: #E3F2FD;
            border-left: 4px solid var(--accent);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .step-list {
            counter-reset: step-counter;
            list-style-type: none;
            padding-left: 0;
        }
        
        .step-list li {
            counter-increment: step-counter;
            margin-bottom: 1rem;
            padding-left: 3rem;
            position: relative;
        }
        
        .step-list li:before {
            content: counter(step-counter);
            background: var(--primary);
            color: white;
            border-radius: 50%;
            width: 2rem;
            height: 2rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            left: 0;
            top: 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>蓝牙USB传输驱动开发实战</h1>
            <p>USB设备枚举、批量传输端点、中断传输处理</p>
        </header>
        
        <section>
            <h2>课程概述</h2>
            <div class="card">
                <p>本课程深入探讨Linux内核中蓝牙USB传输驱动的开发，重点讲解USB设备枚举过程、批量传输端点的配置与使用，以及中断传输的处理机制。通过本课程，您将掌握蓝牙USB设备在Linux系统中的完整驱动开发流程。</p>
            </div>
        </section>
        
        <section>
            <h2>USB设备枚举过程</h2>
            <div class="card">
                <h3>USB枚举基本概念</h3>
                <p>USB枚举是主机识别USB设备并加载相应驱动程序的过程。当蓝牙USB设备插入系统时，内核会执行以下步骤：</p>
                
                <ol class="step-list">
                    <li><strong>设备检测</strong> - USB主机控制器检测到设备连接</li>
                    <li><strong>复位设备</strong> - 主机发送复位信号，设备进入默认状态</li>
                    <li><strong>地址分配</strong> - 主机为设备分配唯一的设备地址</li>
                    <li><strong>描述符读取</strong> - 主机读取设备描述符、配置描述符等</li>
                    <li><strong>驱动匹配</strong> - 内核根据设备信息匹配并加载相应驱动程序</li>
                    <li><strong>配置设置</strong> - 主机设置设备配置，设备进入工作状态</li>
                </ol>
                
                <div class="svg-container">
                    <svg width="100%" height="200" viewBox="0 0 800 200">
                        <rect x="50" y="80" width="100" height="40" rx="5" fill="#4CAF50" stroke="#2E7D32" stroke-width="2"/>
                        <text x="100" y="105" text-anchor="middle" fill="white" font-weight="bold">设备检测</text>
                        
                        <rect x="180" y="80" width="100" height="40" rx="5" fill="#2196F3" stroke="#1565C0" stroke-width="2"/>
                        <text x="230" y="105" text-anchor="middle" fill="white" font-weight="bold">复位设备</text>
                        
                        <rect x="310" y="80" width="100" height="40" rx="5" fill="#FF9800" stroke="#EF6C00" stroke-width="2"/>
                        <text x="360" y="105" text-anchor="middle" fill="white" font-weight="bold">地址分配</text>
                        
                        <rect x="440" y="80" width="100" height="40" rx="5" fill="#9C27B0" stroke="#6A1B9A" stroke-width="2"/>
                        <text x="490" y="105" text-anchor="middle" fill="white" font-weight="bold">描述符读取</text>
                        
                        <rect x="570" y="80" width="100" height="40" rx="5" fill="#F44336" stroke="#C62828" stroke-width="2"/>
                        <text x="620" y="105" text-anchor="middle" fill="white" font-weight="bold">驱动匹配</text>
                        
                        <rect x="700" y="80" width="100" height="40" rx="5" fill="#607D8B" stroke="#37474F" stroke-width="2"/>
                        <text x="750" y="105" text-anchor="middle" fill="white" font-weight="bold">配置设置</text>
                        
                        <line x1="150" y1="100" x2="180" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <line x1="280" y1="100" x2="310" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <line x1="410" y1="100" x2="440" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <line x1="540" y1="100" x2="570" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <line x1="670" y1="100" x2="700" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
                        
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                
                <h3>USB设备描述符结构</h3>
                <table>
                    <thead>
                        <tr>
                            <th>描述符类型</th>
                            <th>大小(字节)</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>设备描述符</td>
                            <td>18</td>
                            <td>包含设备的基本信息，如厂商ID、产品ID等</td>
                        </tr>
                        <tr>
                            <td>配置描述符</td>
                            <td>9</td>
                            <td>描述设备的配置信息</td>
                        </tr>
                        <tr>
                            <td>接口描述符</td>
                            <td>9</td>
                            <td>描述设备提供的接口</td>
                        </tr>
                        <tr>
                            <td>端点描述符</td>
                            <td>7</td>
                            <td>描述端点的类型和属性</td>
                        </tr>
                        <tr>
                            <td>字符串描述符</td>
                            <td>可变</td>
                            <td>提供可读的字符串信息</td>
                        </tr>
                    </tbody>
                </table>
                
                <h3>蓝牙USB驱动注册代码示例</h3>
                <div class="code-block">
<pre>
#include &lt;linux/module.h&gt;
#include &lt;linux/usb.h&gt;

/* 蓝牙USB设备ID表 */
static struct usb_device_id bt_usb_table[] = {
    { USB_DEVICE(0x0a12, 0x0001) }, /* Cambridge Silicon Radio */
    { USB_DEVICE(0x0a5c, 0x21e8) }, /* Broadcom BCM20702A0 */
    { } /* 终止条目 */
};

MODULE_DEVICE_TABLE(usb, bt_usb_table);

/* USB驱动结构体 */
static struct usb_driver bt_usb_driver = {
    .name = "bt_usb",
    .probe = bt_usb_probe,
    .disconnect = bt_usb_disconnect,
    .id_table = bt_usb_table,
};

/* 模块初始化 */
static int __init bt_usb_init(void)
{
    return usb_register(&bt_usb_driver);
}

/* 模块退出 */
static void __exit bt_usb_exit(void)
{
    usb_deregister(&bt_usb_driver);
}

module_init(bt_usb_init);
module_exit(bt_usb_exit);
</pre>
                </div>
            </div>
        </section>
        
        <section>
            <h2>批量传输端点</h2>
            <div class="card">
                <h3>批量传输概述</h3>
                <p>批量传输用于传输大量数据，具有错误检测和重传机制，但不保证传输延迟。在蓝牙USB驱动中，批量传输通常用于：</p>
                <ul>
                    <li>HCI命令的发送与接收</li>
                    <li>ACL数据的传输</li>
                    <li>SCO数据的传输（某些实现）</li>
                </ul>
                
                <div class="svg-container">
                    <svg width="100%" height="300" viewBox="0 0 800 300">
                        <!-- 主机 -->
                        <rect x="50" y="50" width="200" height="100" rx="10" fill="#E3F2FD" stroke="#2196F3" stroke-width="2"/>
                        <text x="150" y="80" text-anchor="middle" font-weight="bold" fill="#1565C0">USB主机</text>
                        <text x="150" y="110" text-anchor="middle" fill="#1565C0">(Linux内核)</text>
                        
                        <!-- USB总线 -->
                        <rect x="270" y="90" width="260" height="20" fill="#BDBDBD"/>
                        <text x="400" y="105" text-anchor="middle" fill="#424242" font-weight="bold">USB总线</text>
                        
                        <!-- 设备 -->
                        <rect x="550" y="50" width="200" height="100" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="650" y="80" text-anchor="middle" font-weight="bold" fill="#2E7D32">蓝牙USB设备</text>
                        <text x="650" y="110" text-anchor="middle" fill="#2E7D32">(HCI层)</text>
                        
                        <!-- 批量IN端点 -->
                        <rect x="580" y="150" width="140" height="40" rx="5" fill="#FFE0B2" stroke="#FF9800" stroke-width="2"/>
                        <text x="650" y="175" text-anchor="middle" font-weight="bold" fill="#EF6C00">批量IN端点</text>
                        
                        <!-- 批量OUT端点 -->
                        <rect x="580" y="200" width="140" height="40" rx="5" fill="#C8E6C9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="650" y="225" text-anchor="middle" font-weight="bold" fill="#2E7D32">批量OUT端点</text>
                        
                        <!-- 数据流 -->
                        <line x1="250" y1="100" x2="270" y2="100" stroke="#2196F3" stroke-width="3" marker-end="url(#arrowblue)"/>
                        <line x1="530" y1="100" x2="550" y2="100" stroke="#2196F3" stroke-width="3" marker-end="url(#arrowblue)"/>
                        
                        <line x1="650" y1="150" x2="650" y2="130" stroke="#FF9800" stroke-width="2" marker-end="url(#arroworange)"/>
                        <line x1="650" y1="200" x2="650" y2="180" stroke="#4CAF50" stroke-width="2" marker-end="url(#arrowgreen)"/>
                        
                        <defs>
                            <marker id="arrowblue" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2196F3"/>
                            </marker>
                            <marker id="arroworange" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#FF9800"/>
                            </marker>
                            <marker id="arrowgreen" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#4CAF50"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                
                <h3>批量传输端点配置</h3>
                <div class="code-block">
<pre>
/* 批量传输端点探测 */
static int bt_usb_find_bulk_endpoints(struct usb_interface *intf,
                                     struct usb_endpoint_descriptor *bulk_in,
                                     struct usb_endpoint_descriptor *bulk_out)
{
    struct usb_host_interface *alt;
    struct usb_endpoint_descriptor *ep;
    int i;
    
    alt = intf->cur_altsetting;
    
    for (i = 0; i < alt->desc.bNumEndpoints; i++) {
        ep = &alt->endpoint[i].desc;
        
        if (usb_endpoint_is_bulk_in(ep)) {
            memcpy(bulk_in, ep, sizeof(*ep));
            continue;
        }
        
        if (usb_endpoint_is_bulk_out(ep)) {
            memcpy(bulk_out, ep, sizeof(*ep));
            continue;
        }
    }
    
    if (!bulk_in || !bulk_out)
        return -ENODEV;
        
    return 0;
}

/* 批量传输URB提交 */
static int bt_usb_submit_bulk_urb(struct bt_usb_data *data, 
                                 struct sk_buff *skb,
                                 gfp_t mem_flags)
{
    struct urb *urb;
    int err;
    
    urb = usb_alloc_urb(0, mem_flags);
    if (!urb)
        return -ENOMEM;
    
    usb_fill_bulk_urb(urb, data->udev,
                     usb_sndbulkpipe(data->udev, data->bulk_out_ep),
                     skb->data, skb->len,
                     bt_usb_tx_complete, skb);
    
    usb_anchor_urb(urb, &data->tx_anchor);
    err = usb_submit_urb(urb, mem_flags);
    
    if (err) {
        usb_unanchor_urb(urb);
        usb_free_urb(urb);
        return err;
    }
    
    usb_free_urb(urb);
    return 0;
}
</pre>
                </div>
                
                <div class="note">
                    <strong>注意：</strong> 批量传输端点的最大包大小取决于USB版本和设备能力。USB 2.0的批量端点最大包大小为512字节，而USB 3.0可达到1024字节。
                </div>
            </div>
        </section>
        
        <section>
            <h2>中断传输处理</h2>
            <div class="card">
                <h3>中断传输概述</h3>
                <p>中断传输用于传输小量、有时间要求的数据。在蓝牙USB驱动中，中断传输通常用于：</p>
                <ul>
                    <li>HCI事件通知</li>
                    <li>设备状态变化通知</li>
                    <li>小量数据的实时传输</li>
                </ul>
                
                <h3>中断传输端点配置</h3>
                <div class="code-block">
<pre>
/* 中断URB回调函数 */
static void bt_usb_intr_complete(struct urb *urb)
{
    struct bt_usb_data *data = urb->context;
    struct sk_buff *skb;
    int err;
    
    if (!test_bit(BT_USB_RUNNING, &data->flags))
        return;
        
    if (urb->status == 0) {
        /* 处理接收到的中断数据 */
        skb = bt_skb_alloc(urb->actual_length, GFP_ATOMIC);
        if (skb) {
            skb_put_data(skb, urb->transfer_buffer, urb->actual_length);
            hci_recv_frame(data->hdev, skb);
        }
    } else if (urb->status == -ENOENT || urb->status == -ECONNRESET ||
               urb->status == -ESHUTDOWN) {
        /* URB被取消或设备断开 */
        return;
    }
    
    /* 重新提交中断URB */
    if (test_bit(BT_USB_RUNNING, &data->flags)) {
        usb_anchor_urb(urb, &data->intr_anchor);
        err = usb_submit_urb(urb, GFP_ATOMIC);
        if (err < 0) {
            usb_unanchor_urb(urb);
            return;
        }
    }
}

/* 中断端点初始化 */
static int bt_usb_setup_intr_endpoint(struct bt_usb_data *data)
{
    struct usb_endpoint_descriptor *ep;
    struct urb *urb;
    void *buf;
    int i, pipe, size;
    
    /* 查找中断IN端点 */
    ep = &data->intr_ep->desc;
    
    if (!usb_endpoint_is_int_in(ep))
        return -ENODEV;
    
    pipe = usb_rcvintpipe(data->udev, ep->bEndpointAddress);
    size = usb_endpoint_maxp(ep);
    
    /* 分配中断URB */
    urb = usb_alloc_urb(0, GFP_KERNEL);
    if (!urb)
        return -ENOMEM;
    
    buf = usb_alloc_coherent(data->udev, size, GFP_KERNEL,
                            &urb->transfer_dma);
    if (!buf) {
        usb_free_urb(urb);
        return -ENOMEM;
    }
    
    /* 填充中断URB */
    usb_fill_int_urb(urb, data->udev, pipe, buf, size,
                    bt_usb_intr_complete, data, ep->bInterval);
    
    urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
    data->intr_urb = urb;
    
    return 0;
}
</pre>
                </div>
                
                <h3>中断传输与批量传输对比</h3>
                <table>
                    <thead>
                        <tr>
                            <th>特性</th>
                            <th>中断传输</th>
                            <th>批量传输</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>数据量</td>
                            <td>小量数据（通常≤64字节）</td>
                            <td>大量数据</td>
                        </tr>
                        <tr>
                            <td>传输延迟</td>
                            <td>有保证的最大延迟</td>
                            <td>无保证延迟</td>
                        </tr>
                        <tr>
                            <td>错误处理</td>
                            <td>错误检测和重传</td>
                            <td>错误检测和重传</td>
                        </tr>
                        <tr>
                            <td>带宽占用</td>
                            <td>固定带宽预留</td>
                            <td>利用空闲带宽</td>
                        </tr>
                        <tr>
                            <td>典型应用</td>
                            <td>HCI事件、状态通知</td>
                            <td>HCI命令、ACL数据</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="note">
                    <strong>最佳实践：</strong> 在蓝牙USB驱动中，通常使用中断传输处理HCI事件和状态变化，而使用批量传输处理大量的ACL数据。合理配置端点的轮询间隔可以平衡响应时间和系统资源消耗。
                </div>
            </div>
        </section>
        
        <section>
            <h2>驱动架构与实现要点</h2>
            <div class="card">
                <h3>蓝牙USB驱动整体架构</h3>
                <div class="svg-container">
                    <svg width="100%" height="400" viewBox="0 0 800 400">
                        <!-- 应用层 -->
                        <rect x="50" y="20" width="700" height="50" rx="5" fill="#BBDEFB" stroke="#2196F3" stroke-width="2"/>
                        <text x="400" y="50" text-anchor="middle" font-weight="bold" fill="#1565C0">蓝牙应用层 (BlueZ, 应用程序)</text>
                        
                        <!-- HCI层 -->
                        <rect x="50" y="90" width="700" height="50" rx="5" fill="#90CAF9" stroke="#1976D2" stroke-width="2"/>
                        <text x="400" y="120" text-anchor="middle" font-weight="bold" fill="#0D47A1">HCI核心层 (hci_core.c)</text>
                        
                        <!-- USB驱动层 -->
                        <rect x="50" y="160" width="700" height="50" rx="5" fill="#64B5F6" stroke="#1565C0" stroke-width="2"/>
                        <text x="400" y="190" text-anchor="middle" font-weight="bold" fill="#0D47A1">蓝牙USB驱动 (hci_usb.c, btusb.c)</text>
                        
                        <!-- USB核心层 -->
                        <rect x="50" y="230" width="700" height="50" rx="5" fill="#42A5F5" stroke="#0D47A1" stroke-width="2"/>
                        <text x="400" y="260" text-anchor="middle" font-weight="bold" fill="#0D47A1">USB核心层 (usbcore)</text>
                        
                        <!-- USB主机控制器 -->
                        <rect x="50" y="300" width="700" height="50" rx="5" fill="#1E88E5" stroke="#0D47A1" stroke-width="2"/>
                        <text x="400" y="330" text-anchor="middle" font-weight="bold" fill="white">USB主机控制器驱动 (xhci, ehci, ohci)</text>
                        
                        <!-- 硬件层 -->
                        <rect x="50" y="370" width="700" height="50" rx="5" fill="#0D47A1" stroke="#0D47A1" stroke-width="2"/>
                        <text x="400" y="400" text-anchor="middle" font-weight="bold" fill="white">蓝牙USB硬件设备</text>
                        
                        <!-- 连接线 -->
                        <line x1="400" y1="70" x2="400" y2="90" stroke="#666" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        <line x1="400" y1="140" x2="400" y2="160" stroke="#666" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        <line x1="400" y1="210" x2="400" y2="230" stroke="#666" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        <line x1="400" y1="280" x2="400" y2="300" stroke="#666" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        <line x1="400" y1="350" x2="400" y2="370" stroke="#666" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        
                        <defs>
                            <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                
                <h3>关键数据结构</h3>
                <div class="code-block">
<pre>
/* 蓝牙USB设备数据结构 */
struct bt_usb_data {
    struct hci_dev *hdev;
    struct usb_device *udev;
    struct usb_interface *intf;
    
    /* 端点信息 */
    struct usb_endpoint_descriptor *intr_ep;
    struct usb_endpoint_descriptor *bulk_tx_ep;
    struct usb_endpoint_descriptor *bulk_rx_ep;
    
    /* URB管理 */
    struct urb *intr_urb;
    struct sk_buff_head tx_q;
    struct usb_anchor tx_anchor;
    struct usb_anchor intr_anchor;
    
    /* 状态标志 */
    unsigned long flags;
    spinlock_t lock;
    
    /* 工作队列 */
    struct work_struct work;
    struct work_struct waker;
};

/* 标志位定义 */
enum {
    BT_USB_RUNNING,
    BT_USB_SUSPENDING,
    BT_USB_RESETTING,
};
</pre>
                </div>
                
                <h3>驱动初始化流程</h3>
                <ol class="step-list">
                    <li><strong>设备探测</strong> - 在probe函数中初始化数据结构</li>
                    <li><strong>端点发现</strong> - 查找并验证中断和批量端点</li>
                    <li><strong>HCI设备注册</strong> - 注册HCI设备到蓝牙子系统</li>
                    <li><strong>URB初始化</strong> - 分配和初始化URB用于数据传输</li>
                    <li><strong>启动传输</strong> - 提交中断URB开始接收数据</li>
                </ol>
                
                <h3>错误处理与资源管理</h3>
                <div class="code-block">
<pre>
/* 驱动探测函数示例 */
static int bt_usb_probe(struct usb_interface *intf,
                       const struct usb_device_id *id)
{
    struct bt_usb_data *data;
    struct hci_dev *hdev;
    int err;
    
    /* 分配驱动数据结构 */
    data = kzalloc(sizeof(*data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;
    
    /* 初始化数据结构 */
    data->udev = usb_get_dev(interface_to_usbdev(intf));
    data->intf = intf;
    skb_queue_head_init(&data->tx_q);
    init_usb_anchor(&data->tx_anchor);
    init_usb_anchor(&data->intr_anchor);
    spin_lock_init(&data->lock);
    
    /* 查找端点 */
    err = bt_usb_find_endpoints(data);
    if (err < 0)
        goto error;
    
    /* 分配HCI设备 */
    hdev = hci_alloc_dev();
    if (!hdev) {
        err = -ENOMEM;
        goto error;
    }
    
    data->hdev = hdev;
    hdev->bus = HCI_USB;
    hdev->driver_data = data;
    hdev->open = bt_usb_open;
    hdev->close = bt_usb_close;
    hdev->send = bt_usb_send_frame;
    hdev->setup = bt_usb_setup;
    
    /* 注册HCI设备 */
    err = hci_register_dev(hdev);
    if (err < 0) {
        hci_free_dev(hdev);
        goto error;
    }
    
    usb_set_intfdata(intf, data);
    return 0;
    
error:
    bt_usb_free(data);
    return err;
}
</pre>
                </div>
            </div>
        </section>
        
        <section>
            <h2>总结</h2>
            <div class="card">
                <p>蓝牙USB传输驱动开发涉及USB设备枚举、批量传输端点和中断传输处理三个核心部分。通过本课程的学习，您应该掌握：</p>
                <ul>
                    <li>USB设备枚举的完整流程和关键步骤</li>
                    <li>批量传输端点的配置、使用和错误处理</li>
                    <li>中断传输的特点、应用场景和实现方法</li>
                    <li>蓝牙USB驱动的整体架构和关键数据结构</li>
                    <li>驱动初始化的完整流程和资源管理</li>
                </ul>
                <p>在实际开发中，需要特别注意USB规范兼容性、资源管理和错误处理，确保驱动的稳定性和性能。</p>
            </div>
        </section>
        
        <footer>
            蓝海资料掘金营
        </footer>
    </div>
</body>
</html>