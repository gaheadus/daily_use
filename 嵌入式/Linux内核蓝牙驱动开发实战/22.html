<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蓝牙多连接管理 - Linux内核蓝牙驱动开发实战</title>
    <style>
        :root {
            --primary: #4CAF50;
            --secondary: #FFC107;
            --accent: #2196F3;
            --light: #E8F5E9;
            --dark: #2E7D32;
            --text: #333333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text);
            background: linear-gradient(135deg, var(--light) 0%, #FFFFFF 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--dark) 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 15px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            border-left: 5px solid var(--accent);
        }
        
        h2 {
            color: var(--dark);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--secondary);
        }
        
        h3 {
            color: var(--primary);
            margin: 1.5rem 0 1rem 0;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }
        
        .card {
            background: var(--light);
            border-radius: 10px;
            padding: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card h4 {
            color: var(--dark);
            margin-bottom: 1rem;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: var(--primary);
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-family: 'Courier New', monospace;
        }
        
        .code-block {
            position: relative;
        }
        
        .code-header {
            background: #555;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px 8px 0 0;
            font-size: 0.9rem;
        }
        
        .architecture {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
        }
        
        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
            background: linear-gradient(135deg, var(--dark) 0%, var(--primary) 100%);
            color: white;
            border-radius: 15px;
        }
        
        .feature-list {
            list-style-type: none;
            padding-left: 0;
        }
        
        .feature-list li {
            padding: 0.5rem 0;
            padding-left: 2rem;
            position: relative;
        }
        
        .feature-list li:before {
            content: "✓";
            position: absolute;
            left: 0;
            color: var(--primary);
            font-weight: bold;
        }
        
        .comparison-table th:first-child {
            width: 30%;
        }
        
        .highlight {
            background-color: var(--secondary);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>蓝牙多连接管理</h1>
            <div class="subtitle">ACL连接管理、SCO连接管理、eSCO连接优化</div>
        </header>

        <section class="section">
            <h2>概述</h2>
            <p>蓝牙多连接管理是蓝牙协议栈中的核心功能，负责管理设备间的多种连接类型。在Linux内核蓝牙驱动开发中，理解并正确实现多连接管理对于构建稳定、高效的蓝牙系统至关重要。</p>
            
            <div class="card-grid">
                <div class="card">
                    <h4>ACL连接</h4>
                    <p>异步无连接链路，用于数据传输</p>
                </div>
                <div class="card">
                    <h4>SCO连接</h4>
                    <p>同步面向连接链路，用于语音传输</p>
                </div>
                <div class="card">
                    <h4>eSCO连接</h4>
                    <p>增强型SCO，提供更好的语音质量和重传机制</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>ACL连接管理</h2>
            <p>ACL（Asynchronous Connection-Less）连接是蓝牙设备间数据传输的主要方式，支持异步数据通信。</p>
            
            <h3>ACL连接特性</h3>
            <ul class="feature-list">
                <li>异步数据传输</li>
                <li>支持广播和多播</li>
                <li>可配置的数据包类型和大小</li>
                <li>支持数据重传和流控</li>
                <li>动态带宽分配</li>
            </ul>
            
            <h3>ACL连接状态管理</h3>
            <table>
                <tr>
                    <th>状态</th>
                    <th>描述</th>
                    <th>内核API</th>
                </tr>
                <tr>
                    <td>STANDBY</td>
                    <td>设备未连接，处于待机状态</td>
                    <td>hci_dev_setup()</td>
                </tr>
                <tr>
                    <td>CONNECTING</td>
                    <td>正在建立连接</td>
                    <td>hci_connect()</td>
                </tr>
                <tr>
                    <td>CONNECTED</td>
                    <td>连接已建立，可进行数据传输</td>
                    <td>hci_conn_check_link_mode()</td>
                </tr>
                <tr>
                    <td>DISCONNECTING</td>
                    <td>正在断开连接</td>
                    <td>hci_disconnect()</td>
                </tr>
            </table>
            
            <h3>ACL连接代码示例</h3>
            <div class="code-block">
                <div class="code-header">Linux内核蓝牙驱动 - ACL连接管理</div>
                <pre><code>// ACL连接建立
static int hci_acl_connect(struct hci_conn *conn)
{
    struct hci_dev *hdev = conn->hdev;
    struct inquiry_entry *ie;
    
    BT_DBG("hcon %p", conn);
    
    /* 检查设备是否在白名单中 */
    if (hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type))
        return hci_le_create_conn(conn);
    
    /* 传统蓝牙连接 */
    conn->state = BT_CONNECT;
    conn->out = true;
    conn->link_mode = HCI_LM_MASTER;
    
    return hci_send_cmd(hdev, HCI_OP_CREATE_CONN, 
                       sizeof(conn->dst), &conn->dst);
}

// ACL数据包发送
static void hci_acl_send_data(struct hci_conn *conn, struct sk_buff *skb)
{
    struct hci_dev *hdev = conn->hdev;
    
    /* 设置ACL数据包头 */
    hci_add_acl_hdr(skb, conn->handle, 
                   ACL_START_NO_FLUSH, 
                   skb->len);
    
    /* 发送数据 */
    hci_send_frame(hdev, skb);
}</code></pre>
            </div>
        </section>

        <section class="section">
            <h2>SCO连接管理</h2>
            <p>SCO（Synchronous Connection-Oriented）连接专为语音通信设计，提供同步、低延迟的音频传输。</p>
            
            <h3>SCO连接特性</h3>
            <ul class="feature-list">
                <li>同步语音传输</li>
                <li>固定带宽预留</li>
                <li>低延迟通信</li>
                <li>不支持数据重传</li>
                <li>典型的64kbps带宽</li>
            </ul>
            
            <h3>SCO连接参数配置</h3>
            <table class="comparison-table">
                <tr>
                    <th>参数</th>
                    <th>HV1</th>
                    <th>HV2</th>
                    <th>HV3</th>
                </tr>
                <tr>
                    <td>数据包类型</td>
                    <td>HV1</td>
                    <td>HV2</td>
                    <td>HV3</td>
                </tr>
                <tr>
                    <td>间隔(slots)</td>
                    <td>2</td>
                    <td>4</td>
                    <td>6</td>
                </tr>
                <tr>
                    <td>带宽(kbps)</td>
                    <td>64</td>
                    <td>64</td>
                    <td>64</td>
                </tr>
                <tr>
                    <td>FEC编码</td>
                    <td>1/3</td>
                    <td>2/3</td>
                    <td>无</td>
                </tr>
            </table>
            
            <h3>SCO连接建立流程</h3>
            <div class="code-block">
                <div class="code-header">Linux内核 - SCO连接管理</div>
                <pre><code>// SCO连接建立
int hci_sco_setup(struct hci_conn *conn, __u8 setting)
{
    struct hci_dev *hdev = conn->hdev;
    struct hci_cp_setup_sync_conn cp;
    
    BT_DBG("hcon %p", conn);
    
    conn->state = BT_CONNECT;
    conn->out = true;
    conn->attempt++;
    
    /* 配置SCO连接参数 */
    cp.handle = cpu_to_le16(conn->handle);
    cp.tx_bandwidth = cpu_to_le32(8000);    // 8kHz
    cp.rx_bandwidth = cpu_to_le32(8000);
    cp.voice_setting = cpu_to_le16(setting);
    cp.retrans_effort = 0xff;               // 不重传
    cp.pkt_type = cpu_to_le16(hdev->sco_pkt_type);
    
    hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, 
                sizeof(cp), &cp);
    
    return 0;
}

// SCO数据包处理
static void hci_sco_recv_frame(struct hci_dev *hdev, 
                              struct sk_buff *skb)
{
    struct hci_sco_hdr *hdr = (void *)skb->data;
    struct hci_conn *conn;
    __u16 handle;
    
    skb_pull(skb, HCI_SCO_HDR_SIZE);
    
    handle = __le16_to_cpu(hdr->handle);
    conn = hci_conn_hash_lookup_handle(hdev, handle);
    
    if (conn) {
        /* 传递SCO数据到上层 */
        hci_skb_pkt_type(skb) = HCI_SCODATA_PKT;
        skb_queue_tail(&conn->data_q, skb);
        schedule_work(&conn->rx_work);
    } else {
        kfree_skb(skb);
    }
}</code></pre>
            </div>
        </section>

        <section class="section">
            <h2>eSCO连接优化</h2>
            <p>eSCO（Enhanced SCO）是SCO的增强版本，提供了更好的语音质量和灵活的参数配置。</p>
            
            <h3>eSCO优化特性</h3>
            <ul class="feature-list">
                <li>支持数据重传机制</li>
                <li>可变的包大小和间隔</li>
                <li>更好的带宽利用率</li>
                <li>支持多种语音编码</li>
                <li>灵活的参数协商</li>
            </ul>
            
            <h3>eSCO与SCO对比</h3>
            <table class="comparison-table">
                <tr>
                    <th>特性</th>
                    <th>SCO</th>
                    <th>eSCO</th>
                </tr>
                <tr>
                    <td>重传机制</td>
                    <td>不支持</td>
                    <td>支持</td>
                </tr>
                <tr>
                    <td>包类型</td>
                    <td>固定</td>
                    <td>可变</td>
                </tr>
                <tr>
                    <td>带宽利用</td>
                    <td>固定64kbps</td>
                    <td>可配置</td>
                </tr>
                <tr>
                    <td>延迟</td>
                    <td>固定</td>
                    <td>可协商</td>
                </tr>
                <tr>
                    <td>语音质量</td>
                    <td>基础</td>
                    <td>增强</td>
                </tr>
            </table>
            
            <h3>eSCO连接优化实现</h3>
            <div class="code-block">
                <div class="code-header">Linux内核 - eSCO连接优化</div>
                <pre><code>// eSCO连接参数配置
static int hci_esco_setup(struct hci_conn *conn, 
                         struct esco_params *params)
{
    struct hci_dev *hdev = conn->hdev;
    struct hci_cp_setup_sync_conn cp;
    
    /* 配置eSCO参数 */
    memset(&cp, 0, sizeof(cp));
    cp.handle = cpu_to_le16(conn->handle);
    cp.tx_bandwidth = cpu_to_le32(params->tx_bw);
    cp.rx_bandwidth = cpu_to_le32(params->rx_bw);
    
    /* eSCO特有参数 */
    cp.retrans_effort = params->retrans_effort;
    cp.pkt_type = cpu_to_le16(params->pkt_type);
    
    /* 语音设置 */
    cp.voice_setting = cpu_to_le16(params->voice_setting);
    
    /* 发送eSCO连接请求 */
    return hci_send_cmd(hdev, HCI_OP_ENHANCED_SETUP_SYNC_CONN,
                       sizeof(cp), &cp);
}

// eSCO重传处理
static void hci_esco_retransmit(struct hci_conn *conn,
                               struct sk_buff *skb)
{
    if (conn->sent < conn->max_tx) {
        /* 重传数据包 */
        hci_send_frame(conn->hdev, skb);
        conn->sent++;
    } else {
        /* 超过最大重传次数，丢弃数据包 */
        kfree_skb(skb);
        BT_DBG("eSCO packet dropped after %d retries", 
               conn->max_tx);
    }
}

// eSCO链路质量监控
static void hci_esco_monitor_quality(struct hci_conn *conn)
{
    struct esco_stats *stats = &conn->esco_stats;
    unsigned int packet_loss;
    
    /* 计算丢包率 */
    packet_loss = (stats->tx_failed * 100) / 
                  (stats->tx_total ?: 1);
    
    /* 根据丢包率调整参数 */
    if (packet_loss > 10) {
        /* 增加重传次数或调整包类型 */
        conn->max_tx = min(conn->max_tx + 1, 3);
        BT_DBG("Increased retransmission to %d", 
               conn->max_tx);
    } else if (packet_loss < 2) {
        /* 减少重传次数以降低延迟 */
        conn->max_tx = max(conn->max_tx - 1, 1);
        BT_DBG("Decreased retransmission to %d", 
               conn->max_tx);
    }
}</code></pre>
            </div>
        </section>

        <section class="section">
            <h2>多连接管理架构</h2>
            <p>Linux内核蓝牙协议栈的多连接管理采用分层架构，确保不同类型连接的协同工作。</p>
            
            <div class="architecture">
                <svg width="100%" height="400" viewBox="0 0 800 400">
                    <!-- 应用层 -->
                    <rect x="50" y="50" width="700" height="60" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                    <text x="400" y="85" text-anchor="middle" font-family="Arial" font-size="16" fill="#2E7D32">应用层 (Profiles: A2DP, HFP, SPP)</text>
                    
                    <!-- L2CAP层 -->
                    <rect x="100" y="130" width="600" height="60" rx="10" fill="#E3F2FD" stroke="#2196F3" stroke-width="2"/>
                    <text x="400" y="165" text-anchor="middle" font-family="Arial" font-size="16" fill="#1565C0">L2CAP层 (逻辑信道多路复用)</text>
                    
                    <!-- HCI层 -->
                    <rect x="150" y="210" width="500" height="60" rx="10" fill="#FFF3E0" stroke="#FF9800" stroke-width="2"/>
                    <text x="400" y="245" text-anchor="middle" font-family="Arial" font-size="16" fill="#E65100">HCI层 (主机控制器接口)</text>
                    
                    <!-- 连接管理层 -->
                    <rect x="200" y="290" width="400" height="60" rx="10" fill="#FCE4EC" stroke="#E91E63" stroke-width="2"/>
                    <text x="400" y="325" text-anchor="middle" font-family="Arial" font-size="16" fill="#AD1457">连接管理层 (ACL/SCO/eSCO)</text>
                    
                    <!-- 连接线 -->
                    <line x1="400" y1="110" x2="400" y2="130" stroke="#666" stroke-width="2"/>
                    <line x1="400" y1="190" x2="400" y2="210" stroke="#666" stroke-width="2"/>
                    <line x1="400" y1="270" x2="400" y2="290" stroke="#666" stroke-width="2"/>
                    
                    <!-- 连接类型标注 -->
                    <text x="50" y="370" font-family="Arial" font-size="14" fill="#333">ACL连接: 数据传输</text>
                    <text x="300" y="370" font-family="Arial" font-size="14" fill="#333">SCO连接: 语音传输</text>
                    <text x="550" y="370" font-family="Arial" font-size="14" fill="#333">eSCO连接: 增强语音</text>
                </svg>
            </div>
            
            <h3>多连接调度策略</h3>
            <ul class="feature-list">
                <li><span class="highlight">时间片轮转</span>：为不同连接类型分配固定时间片</li>
                <li><span class="highlight">优先级调度</span>：SCO/eSCO连接优先于ACL连接</li>
                <li><span class="highlight">动态带宽分配</span>：根据连接需求动态调整带宽</li>
                <li><span class="highlight">连接状态管理</span>：维护连接状态机和超时处理</li>
            </ul>
        </section>

        <section class="section">
            <h2>最佳实践与优化建议</h2>
            
            <h3>性能优化策略</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>连接参数调优</h4>
                    <p>根据应用场景优化ACL、SCO、eSCO的连接参数，平衡延迟和吞吐量</p>
                </div>
                <div class="card">
                    <h4>资源管理</h4>
                    <p>合理管理连接句柄、缓冲区和定时器资源，避免资源泄漏</p>
                </div>
                <div class="card">
                    <h4>错误处理</h4>
                    <p>实现健壮的错误处理机制，确保连接异常时的优雅恢复</p>
                </div>
            </div>
            
            <h3>调试与监控</h3>
            <div class="code-block">
                <div class="code-header">连接状态监控</div>
                <pre><code>// 连接状态监控示例
static void monitor_connection_quality(struct hci_conn *conn)
{
    struct connection_stats *stats = &conn->stats;
    
    /* 记录连接统计信息 */
    stats->total_packets++;
    stats->tx_packets += conn->sent;
    stats->rx_packets += conn->received;
    
    /* 计算连接质量指标 */
    unsigned int success_rate = (conn->received * 100) / 
                               (conn->sent ?: 1);
    
    /* 输出调试信息 */
    BT_DBG("Conn %p: TX=%u, RX=%u, Success=%u%%", 
           conn, conn->sent, conn->received, success_rate);
    
    /* 质量阈值检查 */
    if (success_rate < 80) {
        BT_WARN("Poor connection quality: %u%%", success_rate);
        schedule_connection_optimization(conn);
    }
}

// 通过debugfs暴露连接信息
static const struct file_operations conn_stats_fops = {
    .owner = THIS_MODULE,
    .open = simple_open,
    .read = conn_stats_read,
    .llseek = default_llseek,
};

static int __init bluetooth_debug_init(void)
{
    struct dentry *dir;
    
    dir = debugfs_create_dir("bluetooth", NULL);
    debugfs_create_file("connections", 0444, dir, 
                       NULL, &conn_stats_fops);
    
    return 0;
}</code></pre>
            </div>
        </section>

        <footer>
            <p>蓝海资料掘金营</p>
            <p>《Linux内核蓝牙驱动开发实战》课程资料</p>
        </footer>
    </div>
</body>
</html>