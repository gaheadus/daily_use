<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蓝牙设备文件操作 - Linux内核蓝牙驱动开发实战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #f9fbe7 50%, #e8f5e9 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px dashed #4db6ac;
        }
        
        .header h1 {
            color: #00695c;
            font-size: 2.5rem;
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .header p {
            color: #00796b;
            font-size: 1.2rem;
        }
        
        .section {
            margin-bottom: 40px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        
        .section:hover {
            transform: translateY(-5px);
        }
        
        .section h2 {
            color: #004d40;
            border-left: 5px solid #4db6ac;
            padding-left: 15px;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }
        
        .section h3 {
            color: #00796b;
            margin: 20px 0 15px;
            font-size: 1.4rem;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0f2f1;
        }
        
        th {
            background-color: #4db6ac;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f1f8e9;
        }
        
        tr:hover {
            background-color: #e0f2f1;
        }
        
        .code-block {
            background-color: #f5f5f5;
            border-left: 4px solid #4db6ac;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
            overflow-x: auto;
        }
        
        pre {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .architecture {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }
        
        .architecture svg {
            max-width: 100%;
            height: auto;
        }
        
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px dashed #4db6ac;
            color: #00796b;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .note {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .tip {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>蓝牙设备文件操作</h1>
            <p>字符设备文件操作集、ioctl命令实现、读写缓冲区管理</p>
        </div>
        
        <div class="section">
            <h2>概述</h2>
            <p>在Linux内核中，蓝牙设备通过字符设备文件与用户空间进行交互。这些设备文件操作是蓝牙驱动开发的核心部分，包括字符设备文件操作集的实现、ioctl命令的处理以及读写缓冲区的管理。</p>
            
            <div class="architecture">
                <svg width="800" height="200" viewBox="0 0 800 200">
                    <rect x="50" y="50" width="150" height="60" rx="10" fill="#4db6ac" stroke="#00796b" stroke-width="2"/>
                    <text x="125" y="85" text-anchor="middle" fill="white" font-weight="bold">用户空间</text>
                    
                    <rect x="250" y="50" width="150" height="60" rx="10" fill="#81c784" stroke="#388e3c" stroke-width="2"/>
                    <text x="325" y="85" text-anchor="middle" fill="white" font-weight="bold">VFS层</text>
                    
                    <rect x="450" y="50" width="150" height="60" rx="10" fill="#aed581" stroke="#689f38" stroke-width="2"/>
                    <text x="525" y="85" text-anchor="middle" fill="white" font-weight="bold">字符设备</text>
                    
                    <rect x="650" y="50" width="150" height="60" rx="10" fill="#fff176" stroke="#f57f17" stroke-width="2"/>
                    <text x="725" y="85" text-anchor="middle" fill="#5d4037" font-weight="bold">蓝牙驱动</text>
                    
                    <path d="M200 80 L250 80" stroke="#00796b" stroke-width="2" fill="none"/>
                    <path d="M400 80 L450 80" stroke="#00796b" stroke-width="2" fill="none"/>
                    <path d="M600 80 L650 80" stroke="#00796b" stroke-width="2" fill="none"/>
                    
                    <text x="125" y="150" text-anchor="middle" fill="#004d40">应用层</text>
                    <text x="325" y="150" text-anchor="middle" fill="#004d40">虚拟文件系统</text>
                    <text x="525" y="150" text-anchor="middle" fill="#004d40">字符设备接口</text>
                    <text x="725" y="150" text-anchor="middle" fill="#004d40">硬件驱动层</text>
                </svg>
            </div>
        </div>
        
        <div class="section">
            <h2>字符设备文件操作集</h2>
            <p>在Linux内核中，字符设备通过<code>struct file_operations</code>结构体定义其文件操作接口。蓝牙驱动需要实现这个结构体中的关键函数，以支持用户空间对蓝牙设备的操作。</p>
            
            <h3>file_operations结构体</h3>
            <div class="code-block">
                <pre><code>#include &lt;linux/fs.h&gt;

static const struct file_operations bt_fops = {
    .owner = THIS_MODULE,
    .open = bt_dev_open,
    .release = bt_dev_release,
    .read = bt_dev_read,
    .write = bt_dev_write,
    .unlocked_ioctl = bt_dev_ioctl,
    .poll = bt_dev_poll,
    .llseek = no_llseek,
};</code></pre>
            </div>
            
            <h3>关键函数实现</h3>
            <table>
                <thead>
                    <tr>
                        <th>函数</th>
                        <th>描述</th>
                        <th>实现要点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>open</td>
                        <td>打开设备文件</td>
                        <td>初始化设备状态，分配资源，增加引用计数</td>
                    </tr>
                    <tr>
                        <td>release</td>
                        <td>关闭设备文件</td>
                        <td>释放资源，减少引用计数，清理状态</td>
                    </tr>
                    <tr>
                        <td>read</td>
                        <td>从设备读取数据</td>
                        <td>从内核缓冲区复制数据到用户空间，处理阻塞/非阻塞I/O</td>
                    </tr>
                    <tr>
                        <td>write</td>
                        <td>向设备写入数据</td>
                        <td>从用户空间复制数据到内核缓冲区，处理数据流控制</td>
                    </tr>
                    <tr>
                        <td>ioctl</td>
                        <td>设备控制命令</td>
                        <td>处理各种设备特定命令，如配置参数、查询状态等</td>
                    </tr>
                    <tr>
                        <td>poll</td>
                        <td>查询设备状态</td>
                        <td>检查设备是否可读/可写，支持select/poll/epoll</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="tip">
                <p><strong>提示：</strong> 在实现文件操作函数时，需要注意内核空间与用户空间的数据交换安全性，使用<code>copy_to_user()</code>和<code>copy_from_user()</code>函数。</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ioctl命令实现</h2>
            <p>ioctl（输入输出控制）是设备驱动中用于执行特定设备命令的接口。在蓝牙驱动中，ioctl用于配置设备参数、查询状态和执行特定操作。</p>
            
            <h3>ioctl命令定义</h3>
            <p>ioctl命令通常使用<code>_IO</code>、<code>_IOR</code>、<code>_IOW</code>和<code>_IOWR</code>宏定义：</p>
            
            <div class="code-block">
                <pre><code>#include &lt;linux/ioctl.h&gt;

#define BT_MAGIC 'B'

/* 查询蓝牙设备状态 */
#define BT_GET_STATUS _IOR(BT_MAGIC, 0, int)

/* 设置蓝牙设备名称 */
#define BT_SET_NAME _IOW(BT_MAGIC, 1, char[32])

/* 获取蓝牙设备地址 */
#define BT_GET_ADDR _IOR(BT_MAGIC, 2, unsigned char[6])

/* 启动/停止蓝牙扫描 */
#define BT_START_SCAN _IO(BT_MAGIC, 3)
#define BT_STOP_SCAN _IO(BT_MAGIC, 4)

/* 连接指定设备 */
#define BT_CONNECT _IOW(BT_MAGIC, 5, unsigned char[6])

/* 断开当前连接 */
#define BT_DISCONNECT _IO(BT_MAGIC, 6)</code></pre>
            </div>
            
            <h3>ioctl函数实现</h3>
            <div class="code-block">
                <pre><code>static long bt_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct bt_device *dev = file->private_data;
    int ret = 0;
    
    /* 检查设备状态 */
    if (!dev || !dev->initialized) {
        return -ENODEV;
    }
    
    switch (cmd) {
    case BT_GET_STATUS:
        ret = copy_to_user((int __user *)arg, &dev->status, sizeof(dev->status));
        if (ret)
            return -EFAULT;
        break;
        
    case BT_SET_NAME:
        ret = copy_from_user(dev->name, (char __user *)arg, 32);
        if (ret)
            return -EFAULT;
        dev->name[31] = '\0'; /* 确保字符串终止 */
        break;
        
    case BT_GET_ADDR:
        ret = copy_to_user((unsigned char __user *)arg, 
                          dev->bdaddr, sizeof(dev->bdaddr));
        if (ret)
            return -EFAULT;
        break;
        
    case BT_START_SCAN:
        ret = bt_start_scan(dev);
        break;
        
    case BT_STOP_SCAN:
        ret = bt_stop_scan(dev);
        break;
        
    case BT_CONNECT:
        {
            unsigned char addr[6];
            ret = copy_from_user(addr, (unsigned char __user *)arg, 6);
            if (ret)
                return -EFAULT;
            ret = bt_connect(dev, addr);
        }
        break;
        
    case BT_DISCONNECT:
        ret = bt_disconnect(dev);
        break;
        
    default:
        return -ENOTTY; /* 未知命令 */
    }
    
    return ret;
}</code></pre>
            </div>
            
            <div class="note">
                <p><strong>注意：</strong> 在实现ioctl命令时，必须仔细验证用户提供的参数，防止内核空间被恶意用户空间程序破坏。</p>
            </div>
        </div>
        
        <div class="section">
            <h2>读写缓冲区管理</h2>
            <p>蓝牙驱动需要高效管理读写缓冲区，以处理来自用户空间的数据发送和从蓝牙设备接收的数据。</p>
            
            <h3>缓冲区数据结构</h3>
            <div class="code-block">
                <pre><code>struct bt_buffer {
    unsigned char *data;      /* 缓冲区数据指针 */
    size_t size;              /* 缓冲区总大小 */
    size_t head;              /* 读指针 */
    size_t tail;              /* 写指针 */
    size_t len;               /* 当前数据长度 */
    spinlock_t lock;          /* 缓冲区自旋锁 */
    wait_queue_head_t readq;  /* 读等待队列 */
    wait_queue_head_t writeq; /* 写等待队列 */
};</code></pre>
            </div>
            
            <h3>缓冲区操作函数</h3>
            <table>
                <thead>
                    <tr>
                        <th>函数</th>
                        <th>描述</th>
                        <th>实现要点</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>bt_buf_init</td>
                        <td>初始化缓冲区</td>
                        <td>分配内存，初始化指针和锁</td>
                    </tr>
                    <tr>
                        <td>bt_buf_cleanup</td>
                        <td>清理缓冲区</td>
                        <td>释放内存，重置状态</td>
                    </tr>
                    <tr>
                        <td>bt_buf_write</td>
                        <td>向缓冲区写入数据</td>
                        <td>处理环形缓冲区写入，唤醒读等待队列</td>
                    </tr>
                    <tr>
                        <td>bt_buf_read</td>
                        <td>从缓冲区读取数据</td>
                        <td>处理环形缓冲区读取，唤醒写等待队列</td>
                    </tr>
                    <tr>
                        <td>bt_buf_available</td>
                        <td>检查可用空间</td>
                        <td>返回可写入的字节数</td>
                    </tr>
                    <tr>
                        <td>bt_buf_data_available</td>
                        <td>检查可读数据</td>
                        <td>返回可读取的字节数</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>读写函数实现示例</h3>
            <div class="code-block">
                <pre><code>static ssize_t bt_dev_read(struct file *file, char __user *buf, 
                          size_t count, loff_t *ppos)
{
    struct bt_device *dev = file->private_data;
    struct bt_buffer *rbuf = &dev->read_buf;
    ssize_t ret = 0;
    unsigned long flags;
    
    if (!dev || !buf)
        return -EINVAL;
    
    /* 非阻塞模式检查 */
    if (file->f_flags & O_NONBLOCK) {
        if (bt_buf_data_available(rbuf) == 0)
            return -EAGAIN;
    }
    
    /* 等待数据可用 */
    if (wait_event_interruptible(rbuf->readq, 
                                bt_buf_data_available(rbuf) > 0))
        return -ERESTARTSYS;
    
    spin_lock_irqsave(&rbuf->lock, flags);
    
    /* 从环形缓冲区读取数据到用户空间 */
    ret = bt_buf_read(rbuf, buf, count);
    
    spin_unlock_irqrestore(&rbuf->lock, flags);
    
    /* 唤醒可能等待写入空间的进程 */
    wake_up_interruptible(&rbuf->writeq);
    
    return ret;
}

static ssize_t bt_dev_write(struct file *file, const char __user *buf,
                           size_t count, loff_t *ppos)
{
    struct bt_device *dev = file->private_data;
    struct bt_buffer *wbuf = &dev->write_buf;
    ssize_t ret = 0;
    unsigned long flags;
    
    if (!dev || !buf)
        return -EINVAL;
    
    /* 非阻塞模式检查 */
    if (file->f_flags & O_NONBLOCK) {
        if (bt_buf_available(wbuf) < count)
            return -EAGAIN;
    }
    
    /* 等待足够的写入空间 */
    if (wait_event_interruptible(wbuf->writeq, 
                                bt_buf_available(wbuf) >= count))
        return -ERESTARTSYS;
    
    spin_lock_irqsave(&wbuf->lock, flags);
    
    /* 从用户空间复制数据到环形缓冲区 */
    ret = bt_buf_write(wbuf, buf, count);
    
    spin_unlock_irqrestore(&wbuf->lock, flags);
    
    /* 唤醒可能等待读取数据的进程 */
    wake_up_interruptible(&wbuf->readq);
    
    /* 实际发送数据到蓝牙设备 */
    if (ret > 0)
        bt_send_data(dev, wbuf->data, ret);
    
    return ret;
}</code></pre>
            </div>
            
            <div class="warning">
                <p><strong>警告：</strong> 在实现读写缓冲区时，必须正确处理并发访问，使用适当的锁机制（如自旋锁）保护共享数据。</p>
            </div>
        </div>
        
        <div class="section">
            <h2>完整设备注册示例</h2>
            <p>以下是一个完整的蓝牙字符设备注册和初始化的示例：</p>
            
            <div class="code-block">
                <pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;

#define BT_DEVICE_NAME "bt_dev"
#define BT_CLASS_NAME "bluetooth"
#define BT_DEV_COUNT 1

static int bt_major;
static struct class *bt_class;
static struct cdev bt_cdev;

static int __init bt_dev_init(void)
{
    dev_t devno;
    int ret;
    
    /* 动态分配主设备号 */
    ret = alloc_chrdev_region(&devno, 0, BT_DEV_COUNT, BT_DEVICE_NAME);
    if (ret < 0) {
        pr_err("Failed to allocate char device region\n");
        return ret;
    }
    
    bt_major = MAJOR(devno);
    
    /* 创建设备类 */
    bt_class = class_create(THIS_MODULE, BT_CLASS_NAME);
    if (IS_ERR(bt_class)) {
        pr_err("Failed to create device class\n");
        unregister_chrdev_region(devno, BT_DEV_COUNT);
        return PTR_ERR(bt_class);
    }
    
    /* 初始化字符设备 */
    cdev_init(&bt_cdev, &bt_fops);
    bt_cdev.owner = THIS_MODULE;
    
    /* 添加字符设备到系统 */
    ret = cdev_add(&bt_cdev, devno, BT_DEV_COUNT);
    if (ret) {
        pr_err("Failed to add char device\n");
        class_destroy(bt_class);
        unregister_chrdev_region(devno, BT_DEV_COUNT);
        return ret;
    }
    
    /* 创建设备文件 */
    device_create(bt_class, NULL, devno, NULL, BT_DEVICE_NAME);
    
    pr_info("Bluetooth device driver loaded (major=%d)\n", bt_major);
    return 0;
}

static void __exit bt_dev_exit(void)
{
    dev_t devno = MKDEV(bt_major, 0);
    
    /* 销毁设备文件 */
    device_destroy(bt_class, devno);
    
    /* 删除字符设备 */
    cdev_del(&bt_cdev);
    
    /* 销毁设备类 */
    class_destroy(bt_class);
    
    /* 释放设备号 */
    unregister_chrdev_region(devno, BT_DEV_COUNT);
    
    pr_info("Bluetooth device driver unloaded\n");
}

module_init(bt_dev_init);
module_exit(bt_dev_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("BlueOcean Mining Camp");
MODULE_DESCRIPTION("Bluetooth Character Device Driver Example");</code></pre>
            </div>
        </div>
        
        <div class="section">
            <h2>总结</h2>
            <p>蓝牙设备文件操作是Linux内核蓝牙驱动开发的核心内容，主要包括：</p>
            <ul>
                <li><span class="highlight">字符设备文件操作集</span>：通过实现<code>file_operations</code>结构体，定义设备与用户空间的交互接口</li>
                <li><span class="highlight">ioctl命令实现</span>：处理设备特定的控制命令，如配置参数、查询状态等</li>
                <li><span class="highlight">读写缓冲区管理</span>：使用环形缓冲区高效处理数据收发，支持阻塞和非阻塞I/O</li>
            </ul>
            
            <p>在实现过程中，需要注意：</p>
            <ol>
                <li>正确处理内核空间与用户空间的数据交换</li>
                <li>使用适当的锁机制保护共享资源</li>
                <li>实现完善的错误处理和资源管理</li>
                <li>支持阻塞和非阻塞I/O模式</li>
                <li>遵循Linux内核编码规范和最佳实践</li>
            </ol>
            
            <div class="tip">
                <p><strong>最佳实践：</strong> 在开发蓝牙驱动时，建议参考Linux内核源码中的<code>drivers/bluetooth/</code>目录，学习官方实现的蓝牙驱动代码。</p>
            </div>
        </div>
        
        <div class="footer">
            蓝海资料掘金营
        </div>
    </div>
</body>
</html>