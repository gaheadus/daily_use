<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>蓝牙驱动错误处理 - Linux内核蓝牙驱动开发实战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #f9fbe7 50%, #e8f5e9 100%);
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 40px 0;
            background: linear-gradient(45deg, #4fc3f7, #81c784);
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            color: white;
        }

        h1 {
            font-size: 2.8em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        h2 {
            color: #2e7d32;
            margin: 25px 0 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #81c784;
        }

        h3 {
            color: #388e3c;
            margin: 20px 0 10px;
        }

        .section {
            background: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
            transition: transform 0.3s ease;
        }

        .section:hover {
            transform: translateY(-5px);
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        li {
            margin-bottom: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background-color: #4fc3f7;
            color: white;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f5f5f5;
        }

        tr:hover {
            background-color: #e1f5fe;
        }

        pre {
            background: #f5f5f5;
            border-left: 4px solid #4fc3f7;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            border-radius: 0 8px 8px 0;
            font-family: 'Courier New', monospace;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }

        code {
            background: #e8f5e9;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #2e7d32;
        }

        .svg-container {
            text-align: center;
            margin: 25px 0;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .svg-container svg {
            max-width: 100%;
            height: auto;
        }

        .note {
            background: #fff9c4;
            border-left: 4px solid #ffd54f;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        footer {
            text-align: center;
            padding: 25px;
            margin-top: 40px;
            background: linear-gradient(45deg, #4fc3f7, #81c784);
            border-radius: 15px;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.1);
        }

        .code-block {
            position: relative;
        }

        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 0;
            right: 0;
            background: #4fc3f7;
            color: white;
            padding: 3px 10px;
            font-size: 0.8em;
            border-radius: 0 0 0 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>蓝牙驱动错误处理</h1>
            <p>错误码定义、异常情况恢复、资源泄漏预防</p>
        </header>

        <div class="section">
            <h2>概述</h2>
            <p>在Linux内核蓝牙驱动开发中，错误处理是确保系统稳定性和可靠性的关键环节。本章将深入探讨蓝牙驱动中的错误码定义、异常情况恢复机制以及资源泄漏预防策略，帮助开发者构建健壮的蓝牙驱动模块。</p>
            
            <div class="svg-container">
                <svg width="800" height="200" viewBox="0 0 800 200">
                    <rect x="50" y="80" width="150" height="40" rx="10" fill="#4fc3f7" stroke="#0288d1" stroke-width="2"/>
                    <text x="125" y="105" text-anchor="middle" fill="white" font-weight="bold">错误码定义</text>
                    
                    <rect x="250" y="80" width="150" height="40" rx="10" fill="#81c784" stroke="#388e3c" stroke-width="2"/>
                    <text x="325" y="105" text-anchor="middle" fill="white" font-weight="bold">异常恢复</text>
                    
                    <rect x="450" y="80" width="150" height="40" rx="10" fill="#fff176" stroke="#f57f17" stroke-width="2"/>
                    <text x="525" y="105" text-anchor="middle" fill="#333" font-weight="bold">资源管理</text>
                    
                    <rect x="650" y="80" width="150" height="40" rx="10" fill="#ff8a65" stroke="#d84315" stroke-width="2"/>
                    <text x="725" y="105" text-anchor="middle" fill="white" font-weight="bold">调试工具</text>
                    
                    <line x1="200" y1="100" x2="250" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrow)"/>
                    <line x1="400" y1="100" x2="450" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrow)"/>
                    <line x1="600" y1="100" x2="650" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrow)"/>
                    
                    <defs>
                        <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L0,6 L9,3 z" fill="#666"/>
                        </marker>
                    </defs>
                </svg>
            </div>
        </div>

        <div class="section">
            <h2>错误码定义</h2>
            <p>Linux内核为蓝牙子系统定义了一套完整的错误码体系，这些错误码在<code>include/uapi/linux/bluetooth.h</code>和相关的头文件中定义。</p>
            
            <h3>常见蓝牙错误码</h3>
            <table>
                <thead>
                    <tr>
                        <th>错误码</th>
                        <th>值</th>
                        <th>描述</th>
                        <th>常见场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>BT_ERR_SUCCESS</td>
                        <td>0</td>
                        <td>操作成功</td>
                        <td>正常操作完成</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_UNKNOWN_CMD</td>
                        <td>0x01</td>
                        <td>未知命令</td>
                        <td>接收到不支持的HCI命令</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_NO_CONNECTION</td>
                        <td>0x02</td>
                        <td>无连接</td>
                        <td>在无连接状态下尝试数据传输</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_HW_FAILURE</td>
                        <td>0x03</td>
                        <td>硬件故障</td>
                        <td>蓝牙控制器硬件错误</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_AUTH_FAILURE</td>
                        <td>0x05</td>
                        <td>认证失败</td>
                        <td>配对或连接认证失败</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_MEMORY_FULL</td>
                        <td>0x07</td>
                        <td>内存已满</td>
                        <td>控制器内存不足</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_CONNECTION_TIMEOUT</td>
                        <td>0x08</td>
                        <td>连接超时</td>
                        <td>建立连接超时</td>
                    </tr>
                    <tr>
                        <td>BT_ERR_MAX_NUMBER_OF_CONNECTIONS</td>
                        <td>0x09</td>
                        <td>达到最大连接数</td>
                        <td>无法建立新连接</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>自定义错误码</h3>
            <p>在驱动开发中，可以根据需要定义自定义错误码：</p>
            <div class="code-block" data-lang="C">
                <pre><code>/* 自定义驱动错误码 */
#define MYBT_ERR_BASE        0x1000
#define MYBT_ERR_INIT_FAILED (MYBT_ERR_BASE + 1)
#define MYBT_ERR_POWER_DOWN  (MYBT_ERR_BASE + 2)
#define MYBT_ERR_FW_LOAD     (MYBT_ERR_BASE + 3)
#define MYBT_ERR_HCI_REG     (MYBT_ERR_BASE + 4)

/* 错误码到字符串的映射 */
static const char *mybt_err_str[] = {
    [MYBT_ERR_INIT_FAILED] = "Driver initialization failed",
    [MYBT_ERR_POWER_DOWN]  = "Bluetooth controller power down",
    [MYBT_ERR_FW_LOAD]     = "Firmware loading failed",
    [MYBT_ERR_HCI_REG]     = "HCI registration failed",
};</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>异常情况恢复</h2>
            <p>蓝牙驱动需要处理各种异常情况，包括硬件故障、协议错误、资源不足等。有效的异常恢复机制是保证系统稳定性的关键。</p>
            
            <h3>异常恢复策略</h3>
            <ul>
                <li><strong>重试机制</strong>：对于临时性错误，实施有限次数的重试</li>
                <li><strong>回退操作</strong>：当操作失败时，回退到之前的安全状态</li>
                <li><strong>资源清理</strong>：确保在错误路径上释放所有已分配的资源</li>
                <li><strong>状态同步</strong>：保持驱动状态与硬件状态的一致性</li>
                <li><strong>用户通知</strong>：通过适当的方式向用户空间报告错误</li>
            </ul>
            
            <h3>HCI命令异常处理示例</h3>
            <div class="code-block" data-lang="C">
                <pre><code>static int hci_send_cmd_with_retry(struct hci_dev *hdev, 
                                  struct sk_buff *skb, int max_retries)
{
    int ret, retries = 0;
    
    while (retries < max_retries) {
        ret = hci_send_frame(hdev, skb);
        
        if (ret == 0) {
            /* 成功发送 */
            return 0;
        }
        
        /* 检查是否为可重试的错误 */
        if (ret == -ENOMEM || ret == -EAGAIN) {
            retries++;
            msleep(10 * retries);  /* 指数退避 */
            continue;
        }
        
        /* 不可恢复的错误 */
        break;
    }
    
    bt_dev_err(hdev, "Failed to send HCI command after %d retries: %d", 
               retries, ret);
    return ret;
}

static void hci_cmd_timeout(struct work_struct *work)
{
    struct hci_dev *hdev = container_of(work, struct hci_dev, 
                                       cmd_timer.work);
    
    bt_dev_err(hdev, "HCI command timeout");
    
    /* 重置蓝牙控制器 */
    if (hdev->send)
        hci_reset_dev(hdev);
}</code></pre>
            </div>
            
            <div class="svg-container">
                <svg width="700" height="300" viewBox="0 0 700 300">
                    <rect x="50" y="50" width="600" height="200" rx="10" fill="#e1f5fe" stroke="#4fc3f7" stroke-width="2"/>
                    
                    <rect x="80" y="80" width="120" height="40" rx="5" fill="#4fc3f7" stroke="#0288d1"/>
                    <text x="140" y="105" text-anchor="middle" fill="white" font-size="12">异常发生</text>
                    
                    <rect x="250" y="80" width="120" height="40" rx="5" fill="#81c784" stroke="#388e3c"/>
                    <text x="310" y="105" text-anchor="middle" fill="white" font-size="12">错误分类</text>
                    
                    <rect x="450" y="80" width="120" height="40" rx="5" fill="#fff176" stroke="#f57f17"/>
                    <text x="510" y="105" text-anchor="middle" fill="#333" font-size="12">恢复策略</text>
                    
                    <rect x="80" y="150" width="120" height="40" rx="5" fill="#ff8a65" stroke="#d84315"/>
                    <text x="140" y="175" text-anchor="middle" fill="white" font-size="12">资源清理</text>
                    
                    <rect x="250" y="150" width="120" height="40" rx="5" fill="#ba68c8" stroke="#7b1fa2"/>
                    <text x="310" y="175" text-anchor="middle" fill="white" font-size="12">状态重置</text>
                    
                    <rect x="450" y="150" width="120" height="40" rx="5" fill="#4db6ac" stroke="#00695c"/>
                    <text x="510" y="175" text-anchor="middle" fill="white" font-size="12">恢复正常</text>
                    
                    <line x1="200" y1="100" x2="250" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    <line x1="370" y1="100" x2="450" y2="100" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    <line x1="200" y1="170" x2="250" y2="170" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    <line x1="370" y1="170" x2="450" y2="170" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    <line x1="570" y1="120" x2="570" y2="150" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    <line x1="570" y1="150" x2="520" y2="150" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>
                    
                    <defs>
                        <marker id="arrow2" markerWidth="8" markerHeight="8" refX="7" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L7,3 z" fill="#666"/>
                        </marker>
                    </defs>
                </svg>
            </div>
        </div>

        <div class="section">
            <h2>资源泄漏预防</h2>
            <p>资源泄漏是驱动开发中常见的问题，特别是在错误处理路径上。蓝牙驱动需要管理多种资源，包括内存、DMA缓冲区、中断、定时器等。</p>
            
            <h3>常见资源泄漏类型</h3>
            <table>
                <thead>
                    <tr>
                        <th>资源类型</th>
                        <th>分配函数</th>
                        <th>释放函数</th>
                        <th>泄漏后果</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>内核内存</td>
                        <td>kmalloc, kzalloc</td>
                        <td>kfree</td>
                        <td>内存耗尽，系统崩溃</td>
                    </tr>
                    <tr>
                        <td>DMA缓冲区</td>
                        <td>dma_alloc_coherent</td>
                        <td>dma_free_coherent</td>
                        <td>DMA内存泄漏，IOMMU错误</td>
                    </tr>
                    <tr>
                        <td>SKB缓冲区</td>
                        <td>alloc_skb</td>
                        <td>kfree_skb</td>
                        <td>网络内存池耗尽</td>
                    </tr>
                    <tr>
                        <td>中断</td>
                        <td>request_irq</td>
                        <td>free_irq</td>
                        <td>无法注销驱动，系统不稳定</td>
                    </tr>
                    <tr>
                        <td>工作队列</td>
                        <td>create_workqueue</td>
                        <td>destroy_workqueue</td>
                        <td>内核线程泄漏</td>
                    </tr>
                    <tr>
                        <td>定时器</td>
                        <td>timer_setup</td>
                        <td>del_timer</td>
                        <td>无效定时器回调</td>
                    </tr>
                </tbody>
            </table>
            
            <h3>资源管理最佳实践</h3>
            <ol>
                <li><strong>使用goto标签统一清理</strong>：在复杂函数中使用goto进行错误处理</li>
                <li><strong>引用计数</strong>：对共享资源使用引用计数机制</li>
                <li><strong>RAII模式</strong>：利用Linux内核的自动清理机制</li>
                <li><strong>内存检测工具</strong>：使用kmemleak检测内存泄漏</li>
                <li><strong>静态分析</strong>：使用sparse、coccinelle等工具进行代码分析</li>
            </ol>
            
            <h3>资源清理示例</h3>
            <div class="code-block" data-lang="C">
                <pre><code>static int bt_driver_probe(struct platform_device *pdev)
{
    struct bt_device *bdev;
    struct hci_dev *hdev;
    int err = 0;
    
    /* 分配设备结构 */
    bdev = devm_kzalloc(&pdev->dev, sizeof(*bdev), GFP_KERNEL);
    if (!bdev)
        return -ENOMEM;
    
    /* 初始化设备 */
    bdev->dev = &pdev->dev;
    platform_set_drvdata(pdev, bdev);
    
    /* 申请中断 */
    err = devm_request_irq(&pdev->dev, pdev->resource[0].start,
                          bt_interrupt, IRQF_SHARED,
                          "bluetooth-device", bdev);
    if (err) {
        dev_err(&pdev->dev, "Failed to request IRQ: %d\n", err);
        return err;
    }
    
    /* 注册HCI设备 */
    hdev = hci_alloc_dev();
    if (!hdev) {
        dev_err(&pdev->dev, "Failed to allocate HCI device\n");
        return -ENOMEM;
    }
    
    bdev->hdev = hdev;
    SET_HCIDEV_DEV(hdev, &pdev->dev);
    hdev->bus = HCI_PCI;
    hdev->open = bt_open;
    hdev->close = bt_close;
    hdev->send = bt_send;
    
    err = hci_register_dev(hdev);
    if (err < 0) {
        dev_err(&pdev->dev, "Failed to register HCI device: %d\n", err);
        hci_free_dev(hdev);
        return err;
    }
    
    return 0;
}

static int bt_driver_remove(struct platform_device *pdev)
{
    struct bt_device *bdev = platform_get_drvdata(pdev);
    struct hci_dev *hdev = bdev->hdev;
    
    /* 注销HCI设备 */
    hci_unregister_dev(hdev);
    hci_free_dev(hdev);
    
    return 0;
}</code></pre>
            </div>
            
            <div class="note">
                <p><strong>注意：</strong>使用<code>devm_</code>系列函数可以自动管理资源，在设备卸载时自动释放，大大减少资源泄漏的可能性。</p>
            </div>
        </div>

        <div class="section">
            <h2>调试与测试</h2>
            <p>有效的调试和测试是发现和修复错误处理问题的关键。</p>
            
            <h3>调试技巧</h3>
            <ul>
                <li><strong>动态调试</strong>：使用<code>dynamic_debug</code>控制调试输出</li>
                <li><strong>跟踪点</strong>：利用<code>tracepoints</code>跟踪函数执行路径</li>
                <li><strong>内存检测</strong>：使用KASAN检测内存错误</li>
                <li><strong>锁检测</strong>：使用lockdep检测锁的使用问题</li>
            </ul>
            
            <h3>错误注入测试</h3>
            <div class="code-block" data-lang="C">
                <pre><code>#ifdef CONFIG_FAULT_INJECTION
#include <linux/fault-inject.h>

static struct fault_attr bt_fail_alloc = {
    .name = "bt_alloc_fail",
    .probability = 0,  /* 默认禁用 */
    .interval = 1,
    .space = 32,
    .times = 1,
    .verbose = 2,
};

static bool should_fail_alloc(void)
{
    return should_fail(&bt_fail_alloc, 1);
}

/* 在内存分配处注入错误 */
static void *bt_alloc_mem(size_t size, gfp_t flags)
{
    if (should_fail_alloc())
        return NULL;
    
    return kmalloc(size, flags);
}
#endif</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>总结</h2>
            <p>蓝牙驱动的错误处理是一个系统工程，需要从错误码定义、异常恢复机制到资源泄漏预防等多个方面进行全面考虑。通过本章的学习，开发者应该能够：</p>
            <ul>
                <li>理解Linux内核蓝牙错误码体系</li>
                <li>设计健壮的异常恢复机制</li>
                <li>预防各种类型的资源泄漏</li>
                <li>使用合适的调试工具检测和修复错误</li>
                <li>编写符合Linux内核编码规范的错误处理代码</li>
            </ul>
            <p>良好的错误处理不仅能提高驱动的稳定性，还能大大减少调试和维护的成本。</p>
        </div>

        <footer>
            蓝海资料掘金营
        </footer>
    </div>
</body>
</html>