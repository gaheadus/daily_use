<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreeRTOS任务与队列通信详解</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #e0f7fa 0%, #f9fbe7 50%, #e8f5e9 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #4fc3f7 0%, #81c784 50%, #4db6ac 100%);
            color: white;
            padding: 30px;
            text-align: center;
            border-bottom: 5px solid #26a69a;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            margin-bottom: 40px;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border-left: 5px solid #4fc3f7;
        }
        
        h2 {
            color: #00796b;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px dashed #80cbc4;
        }
        
        h3 {
            color: #004d40;
            margin: 20px 0 10px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0f2f1;
        }
        
        th {
            background-color: #4db6ac;
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #e0f2f1;
        }
        
        tr:hover {
            background-color: #b2dfdb;
        }
        
        .code-block {
            background: #f5f5f5;
            border-left: 4px solid #4fc3f7;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.4;
        }
        
        .architecture {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }
        
        .architecture svg {
            max-width: 100%;
            height: auto;
        }
        
        .highlight {
            background-color: #fff9c4;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .tip-box {
            background: #e1f5fe;
            border-left: 4px solid #0288d1;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        footer {
            background: linear-gradient(135deg, #4fc3f7 0%, #81c784 50%, #4db6ac 100%);
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 1.1em;
            font-weight: bold;
            margin-top: 30px;
        }
        
        .example-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .example-card {
            background: #f1f8e9;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #c5e1a5;
        }
        
        .example-card h4 {
            color: #33691e;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>FreeRTOS任务与队列通信</h1>
            <div class="subtitle">第41问：任务如何使用队列进行通信</div>
        </header>
        
        <div class="content">
            <div class="section">
                <h2>队列通信概述</h2>
                <p>在FreeRTOS中，队列是任务间通信和同步的核心机制之一。队列提供了一种安全的方式，允许任务在彼此之间发送和接收数据，而无需担心并发访问问题。</p>
                
                <div class="tip-box">
                    <strong>核心概念：</strong> 队列是一种先进先出（FIFO）的数据结构，可以存储固定大小的数据项。多个任务可以安全地向同一个队列写入数据或从同一个队列读取数据。
                </div>
                
                <div class="architecture">
                    <svg width="600" height="300" viewBox="0 0 600 300">
                        <rect x="50" y="50" width="100" height="60" rx="10" fill="#4fc3f7" stroke="#0277bd" stroke-width="2"/>
                        <text x="100" y="85" text-anchor="middle" fill="white" font-weight="bold">任务A</text>
                        
                        <rect x="250" y="40" width="100" height="80" rx="10" fill="#81c784" stroke="#2e7d32" stroke-width="2"/>
                        <text x="300" y="65" text-anchor="middle" fill="white" font-weight="bold">队列</text>
                        <text x="300" y="85" text-anchor="middle" fill="white" font-size="12">数据缓冲区</text>
                        
                        <rect x="450" y="50" width="100" height="60" rx="10" fill="#4fc3f7" stroke="#0277bd" stroke-width="2"/>
                        <text x="500" y="85" text-anchor="middle" fill="white" font-weight="bold">任务B</text>
                        
                        <path d="M150 80 L250 80" stroke="#ff9800" stroke-width="3" marker-end="url(#arrowhead)"/>
                        <text x="200" y="75" text-anchor="middle" fill="#ff9800" font-weight="bold">发送数据</text>
                        
                        <path d="M350 80 L450 80" stroke="#ff9800" stroke-width="3" marker-end="url(#arrowhead)"/>
                        <text x="400" y="75" text-anchor="middle" fill="#ff9800" font-weight="bold">接收数据</text>
                        
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#ff9800"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
            </div>
            
            <div class="section">
                <h2>队列的基本操作</h2>
                
                <h3>1. 创建队列</h3>
                <p>在使用队列之前，必须先创建队列。FreeRTOS提供了<code>xQueueCreate()</code>函数来创建队列。</p>
                
                <div class="code-block">
                    <pre>QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, 
                            UBaseType_t uxItemSize );</pre>
                </div>
                
                <p><strong>参数说明：</strong></p>
                <ul>
                    <li><span class="highlight">uxQueueLength</span>：队列能够存储的最大数据项数量</li>
                    <li><span class="highlight">uxItemSize</span>：每个数据项的大小（字节）</li>
                </ul>
                
                <p><strong>返回值：</strong></p>
                <ul>
                    <li>成功：返回队列句柄</li>
                    <li>失败：返回NULL</li>
                </ul>
                
                <h3>2. 发送数据到队列</h3>
                <p>FreeRTOS提供了多个函数用于向队列发送数据：</p>
                
                <table>
                    <tr>
                        <th>函数</th>
                        <th>描述</th>
                        <th>阻塞时间</th>
                    </tr>
                    <tr>
                        <td>xQueueSend()</td>
                        <td>向队列尾部发送数据</td>
                        <td>可指定</td>
                    </tr>
                    <tr>
                        <td>xQueueSendToFront()</td>
                        <td>向队列头部发送数据</td>
                        <td>可指定</td>
                    </tr>
                    <tr>
                        <td>xQueueSendToBack()</td>
                        <td>向队列尾部发送数据</td>
                        <td>可指定</td>
                    </tr>
                    <tr>
                        <td>xQueueSendFromISR()</td>
                        <td>在中断服务程序中向队列发送数据</td>
                        <td>不阻塞</td>
                    </tr>
                </table>
                
                <h3>3. 从队列接收数据</h3>
                <p>从队列接收数据的函数：</p>
                
                <table>
                    <tr>
                        <th>函数</th>
                        <th>描述</th>
                        <th>阻塞时间</th>
                    </tr>
                    <tr>
                        <td>xQueueReceive()</td>
                        <td>从队列接收数据</td>
                        <td>可指定</td>
                    </tr>
                    <tr>
                        <td>xQueueReceiveFromISR()</td>
                        <td>在中断服务程序中从队列接收数据</td>
                        <td>不阻塞</td>
                    </tr>
                    <tr>
                        <td>uxQueueMessagesWaiting()</td>
                        <td>获取队列中当前的数据项数量</td>
                        <td>不阻塞</td>
                    </tr>
                </table>
            </div>
            
            <div class="section">
                <h2>队列通信示例代码</h2>
                
                <h3>示例1：基本队列通信</h3>
                <div class="code-block">
                    <pre>#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

// 定义队列句柄
QueueHandle_t xQueue;

// 定义数据结构
typedef struct {
    int sensorValue;
    char sensorName[10];
} SensorData_t;

// 发送任务
void vSenderTask(void *pvParameters) {
    SensorData_t dataToSend;
    const TickType_t xDelay = pdMS_TO_TICKS(1000);
    
    for(;;) {
        // 准备数据
        dataToSend.sensorValue = rand() % 100;
        strcpy(dataToSend.sensorName, "Sensor1");
        
        // 发送数据到队列（等待最多100ms）
        if(xQueueSend(xQueue, &dataToSend, pdMS_TO_TICKS(100)) == pdPASS) {
            // 发送成功
        } else {
            // 发送失败（队列满）
        }
        
        vTaskDelay(xDelay);
    }
}

// 接收任务
void vReceiverTask(void *pvParameters) {
    SensorData_t receivedData;
    
    for(;;) {
        // 从队列接收数据（无限期等待）
        if(xQueueReceive(xQueue, &receivedData, portMAX_DELAY) == pdPASS) {
            // 处理接收到的数据
            printf("收到数据: %s = %d\n", 
                   receivedData.sensorName, 
                   receivedData.sensorValue);
        }
    }
}

int main(void) {
    // 创建队列，最多存储5个SensorData_t类型的数据项
    xQueue = xQueueCreate(5, sizeof(SensorData_t));
    
    if(xQueue != NULL) {
        // 创建任务
        xTaskCreate(vSenderTask, "Sender", 1000, NULL, 1, NULL);
        xTaskCreate(vReceiverTask, "Receiver", 1000, NULL, 2, NULL);
        
        // 启动调度器
        vTaskStartScheduler();
    }
    
    return 0;
}</pre>
                </div>
                
                <h3>示例2：多任务队列通信</h3>
                <div class="code-block">
                    <pre>// 多个发送任务向同一个队列发送数据
void vMultiSenderTask(void *pvParameters) {
    int taskId = (int)pvParameters;
    int data = 0;
    const TickType_t xDelay = pdMS_TO_TICKS(500);
    
    for(;;) {
        data = taskId * 100 + (data % 100) + 1;
        
        // 发送数据到队列
        xQueueSend(xQueue, &data, portMAX_DELAY);
        
        printf("任务%d发送数据: %d\n", taskId, data);
        vTaskDelay(xDelay);
    }
}

// 单个接收任务处理来自多个发送任务的数据
void vMultiReceiverTask(void *pvParameters) {
    int receivedData;
    
    for(;;) {
        if(xQueueReceive(xQueue, &receivedData, portMAX_DELAY) == pdPASS) {
            printf("接收任务处理数据: %d\n", receivedData);
            // 根据数据内容进行相应处理
        }
    }
}</pre>
                </div>
            </div>
            
            <div class="section">
                <h2>队列使用的最佳实践</h2>
                
                <div class="example-grid">
                    <div class="example-card">
                        <h4>合理设置队列长度</h4>
                        <p>根据数据产生和消费的速度平衡，设置合适的队列长度，避免内存浪费或数据丢失。</p>
                    </div>
                    
                    <div class="example-card">
                        <h4>选择适当的数据结构</h4>
                        <p>使用结构体封装相关数据，减少队列操作次数，提高通信效率。</p>
                    </div>
                    
                    <div class="example-card">
                        <h4>处理队列满/空情况</h4>
                        <p>合理设置阻塞时间，设计超时处理机制，确保系统不会因队列问题而僵死。</p>
                    </div>
                </div>
                
                <h3>队列使用注意事项</h3>
                <ul>
                    <li>队列操作是线程安全的，多个任务可以同时访问同一个队列</li>
                    <li>在中断服务程序中使用队列时，必须使用FromISR版本的函数</li>
                    <li>合理设置阻塞时间，避免任务无限期等待</li>
                    <li>考虑使用队列集（Queue Sets）监控多个队列</li>
                    <li>注意内存分配，大型数据建议传递指针而非拷贝数据</li>
                </ul>
            </div>
            
            <div class="section">
                <h2>队列与其他通信机制对比</h2>
                
                <table>
                    <tr>
                        <th>通信机制</th>
                        <th>特点</th>
                        <th>适用场景</th>
                    </tr>
                    <tr>
                        <td>队列</td>
                        <td>数据传递、FIFO、线程安全</td>
                        <td>任务间数据交换、生产者-消费者模式</td>
                    </tr>
                    <tr>
                        <td>信号量</td>
                        <td>同步、资源计数</td>
                        <td>资源管理、任务同步</td>
                    </tr>
                    <tr>
                        <td>互斥量</td>
                        <td>互斥访问、优先级继承</td>
                        <td>共享资源保护</td>
                    </tr>
                    <tr>
                        <td>事件组</td>
                        <td>多事件通知、位操作</td>
                        <td>复杂事件同步、多条件等待</td>
                    </tr>
                </table>
            </div>
            
            <div class="section">
                <h2>总结</h2>
                <p>队列是FreeRTOS中实现任务间通信的强大工具，它提供了安全、可靠的数据传递机制。通过合理使用队列，可以构建出高效、稳定的嵌入式多任务系统。</p>
                
                <div class="tip-box">
                    <strong>关键要点：</strong>
                    <ul>
                        <li>队列提供线程安全的数据传递</li>
                        <li>支持阻塞和非阻塞操作</li>
                        <li>可在任务和中断服务程序中使用</li>
                        <li>合理设计队列长度和数据类型至关重要</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <footer>
            蓝海资料掘金营
        </footer>
    </div>
</body>
</html>